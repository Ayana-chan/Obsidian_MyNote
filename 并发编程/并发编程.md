


# 进程间通信 IPC


**管道（Pipe）**
- **匿名管道（Anonymous Pipe）**：
  - **原理**：单向通信，基于内核缓冲区，数据按先进先出（FIFO）传输。
  - **使用场景**：仅限父子进程或兄弟进程等有亲缘关系的进程。
  - **系统调用**：`pipe()` 创建一对文件描述符（读/写端）。
  - **优点**：简单高效。
  - **缺点**：单向通信，只能用于亲缘进程，缓冲区大小有限。

- **命名管道（Named Pipe/FIFO）**：
  - **原理**：通过文件系统路径标识，允许无关进程通信。
  - **使用场景**：无亲缘关系的进程间通信。
  - **创建方式**：`mkfifo()` 系统调用或 `mkfifo` 命令。
  - **优点**：突破亲缘关系限制。
  - **缺点**：仍为单向通信，需显式同步读写。

---

**消息队列（Message Queue）**
- **原理**：内核维护的链表结构消息，进程通过唯一标识符访问。
  - **消息类型**：支持结构化数据，可分类接收（按消息类型）。
  - **生命周期**：随内核持续，需显式删除。
- **系统调用**：`msgget()`, `msgsnd()`, `msgrcv()`。
- **优点**：异步通信，支持多进程读写，无需同步。
- **缺点**：消息大小和队列数量受内核限制，传输效率较低。

---

**共享内存（Shared Memory）**
- **原理**：多个进程映射同一块物理内存到自身地址空间，直接读写。
  - **创建步骤**：`shmget()` 创建共享内存段 → `shmat()` 连接到进程地址空间。
- **优点**：最快的IPC方式，省去数据拷贝。
- **缺点**：需配合信号量等同步机制，否则可能引发竞态条件。
- **典型应用**：高频数据交换（如数据库、图形渲染）。

---

**信号量（Semaphore）**
- **原理**：计数器机制，用于协调多进程对共享资源的访问。
  - **操作**：P（等待，减1）和 V（释放，加1）。
  - **类型**：二元信号量（互斥锁）或计数信号量。
- **系统调用**：`semget()`, `semop()`, `semctl()`。
- **作用**：不直接传递数据，而是<u>保证进程同步</u>。
- **缺点**：需谨慎处理死锁问题。

---

**信号（Signal）**
- **原理**：异步通知机制，向进程发送特定事件（如 `SIGINT` 终止信号）。
  - **处理方式**：忽略（SIG_IGN）、默认（SIG_DFL）或自定义处理函数。
- **系统调用**：`kill()` 发送信号，`signal()` 或 `sigaction()` 注册处理函数。
- **优点**：轻量级，<u>适合简单事件通知</u>。
- **缺点**：无法传递复杂数据，信号处理函数需保持简洁。

> [!note]
> 可以在数据完成写入之后使用信号进行通知, 让其他进程来读取.

---

**套接字（Socket）**
- **原理**：基于网络的通信接口，支持跨机器通信。
  - **本地套接字**：Unix域套接字（AF_UNIX），通过文件系统路径标识。
  - **网络套接字**：TCP/IP（可靠流式）或 UDP（不可靠报文）。
- **优点**：最通用的IPC方式，支持分布式系统。
- **缺点**：协议栈开销较大，性能低于共享内存。

---

**内存映射（Memory-Mapped File）**
- **原理**：将文件映射到进程地址空间，多进程共享同一文件映射。
  - **系统调用**：`mmap()` 创建映射，`munmap()` 解除。
- **优点**：结合文件持久化和共享内存的高效。
- **缺点**：需处理文件同步问题（如 `msync()`）。

---

**其他方式**
- **文件锁（File Locking）**：通过 `flock()` 或 `fcntl()` 控制文件访问。
- **RPC（Remote Procedure Call）**：跨进程函数调用，通常基于Socket或共享内存实现。



# CAS (Compare and Swap)
读取target存入old，进行一些操作，然后计算new值。然后进行CAS原子操作：如果target依然和old一样，则将target更新为new；否则撤销之前做的事情。往往在外部套上循环，不停地尝试CAS直到成功。

是乐观锁。

```
let old = target.read();
do_something();
let new = compute(old);
let result = CAS(target, old, new)
if !result {
	revoke_do_something();
}
```

要求`let new = compute(old);`是无环计算，从而保证对于每个target的值，只有一个线程能抢占到。

# COW (Copy on Write)

数据a被拷贝出数据b时，二者共享同一块数据区域；当其中一个对数据进行写操作时，数据区域被真正拷贝，然后b执行新数据区域。


# RCU (Read - Copy Update)

数据被写时，拷贝出一块内存，在那里进行写，写完后将对应的数据指针指向那块内存。这使得读写不满足线性一致性，也使得读无锁。


# 死锁

死锁的*必要条件*：
1. **互斥条件**：资源（如行锁）只能被一个事务占用，无法同时分配给多个事务。
2. **持有并等待条件**：事务已持有部分资源，同时还在等待其他事务持有的资源。
3. **不可剥夺条件**：事务持有的资源不能被强制收回，只能由事务主动释放。
4. **循环等待条件**：多个事务形成闭环等待，比如事务 A 等事务 B 的资源，事务 B 等事务 A 的资源。

- 破坏 “持有并等待”：要求事务**一次性申请所有需要的资源**，申请不到则不执行，避免 “拿着一部分等另一部分”。
- 破坏 “不可剥夺”：若事务申请新资源失败，强制释放它已持有的所有资源，后续需重新申请。
- 破坏 “循环等待”：给所有资源（如数据表、行记录）设定**固定顺序**，事务必须按顺序申请资源（比如先锁表 A 再锁表 B），避免闭环。

**银行家算法**：
- 相当于一个中心化的资源分配管理器。
- 每个线程申请资源的时候，把要申请的各个东西的数量交给算法，算法看当前剩余的资源是否足够；只要有任意资源不够，就不给此线程任何资源，直到资源足够（在其他线程归还资源后）。

基于**资源分配图（RAG）** 的分配：
- 图结构维护：
    - **请求边**（Transaction → Resource）：事务请求资源。
    - **分配边**（Resource → Transaction）：资源已分配给事务。
- 动态检测：
    1. 当事务请求资源时，在图中添加请求边。
    2. 检查图中是否存在环：若存在环，则拒绝资源请求；否则，分配资源并更新图结构。









