

# pa0

init之后`~/.bashrc`会自动添加（如果不从零开始的话可能得手动添加）：

```bash
export NEMU_HOME=/home/ayana/workspace/ics2023/nemu                         
export AM_HOME=/home/ayana/workspace/ics2023/abstract-machine
```

`make menuconfig`报错时执行：

```bash
sudo apt-get install bison
sudo apt-get install flex
```


# pa1

配置ccache的时候，只需在`~/.bashrc`加入：

```bash
#让ccache的软链接被提到PATH的最高优先级
export PATH="/usr/lib/ccache:$PATH" 
```

配置时会生成的重要文件包括：
- `nemu/include/generated/autoconf.h`, 阅读C代码时使用
- `nemu/include/config/auto.conf`, 阅读Makefile时使用

`$(CFLAGS)`值如下，是gcc编译的参数：

```bash
-O2 -MMD -Wall -Werror -I/home/user/ics2023/nemu/include
-I/home/user/ics2023/nemu/src/engine/interpreter -I/home/use
r/ics2023/nemu/src/isa/riscv32/include -O2    -D__GUEST_ISA__
=riscv32
```

>我们知道内存是一种RAM, 是一种易失性的存储介质, 这意味着计算机刚启动的时候, 内存中的数据都是无意义的; 而BIOS是固化在ROM/Flash中的, 它们都是非易失性的存储介质, BIOS中的内容不会因为断电而丢失.
 因此在真实的计算机系统中, 计算机启动后首先会把控制权交给BIOS, BIOS经过一系列初始化工作之后, 再从磁盘中将有意义的程序读入内存中执行. 对这个过程的模拟需要了解很多超出本课程范围的细节, 我们在PA中做了简化: 采取约定的方式让CPU直接从约定的内存位置开始执行.

>x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样, 例如mips32和riscv32的物理地址均从`0x80000000`开始. 因此对于mips32和riscv32, 其`CONFIG_MBASE`将会被定义成`0x80000000`. 将来CPU访问内存时, 我们会将CPU将要访问的内存地址映射到`pmem`中的相应偏移位置, 这是通过`nemu/src/memory/paddr.c`中的`guest_to_host()`函数实现的. 例如如果mips32的CPU打算访问内存地址`0x80000000`, 我们会让它最终访问`pmem[0]`, 从而可以正确访问客户程序的第一条指令. 这种机制有一个专门的名字, 叫地址映射, 在后续的PA中我们还会再遇到它.

`init_monitor`：

```c
101 void init_monitor(int argc, char *argv[]) {
102   /* Perform some global initialization. */
103 
104   /* Parse arguments. */
105   parse_args(argc, argv);
106 
107   /* Set random seed. */
108   init_rand();
109 
110   /* Open the log file. */
111   init_log(log_file);
112 
113   /* Initialize memory. */
114   init_mem();
115 
116   /* Initialize devices. */
117   IFDEF(CONFIG_DEVICE, init_device());
118 
119   /* Perform ISA dependent initialization. */
120   init_isa();
121 
122   /* Load the image to memory. This will overwrite the built-in image. */
123   long img_size = load_img();
124 
125   /* Initialize differential testing. */
126   init_difftest(diff_so_file, img_size, difftest_port);
127 
128   /* Initialize the simple debugger. */
129   init_sdb();
130 
131 #ifndef CONFIG_ISA_loongarch32r
132   IFDEF(CONFIG_ITRACE, init_disasm(
133     MUXDEF(CONFIG_ISA_x86,     "i686",
134     MUXDEF(CONFIG_ISA_mips32,  "mipsel",
135     MUXDEF(CONFIG_ISA_riscv,
136       MUXDEF(CONFIG_RV64,      "riscv64",
137                                "riscv32"),
138                                "bad"))) "-pc-linux-gnu"
139   ));
140   #endif
141 
142   /* Display welcome message. */
143   welcome();
144 }
```

`load_img()`函数 (在`nemu/src/monitor/monitor.c`中定义)会将一个有意义的客户程序从[镜像文件](https://en.wikipedia.org/wiki/Disk_image)读入到内存, 覆盖刚才的内置客户程序. 这个镜像文件是运行NEMU的一个可选参数, 在运行NEMU的命令中指定. 如果运行NEMU的时候没有给出这个参数, NEMU将会运行内置客户程序.

Monitor的初始化工作结束后, `main()`函数会继续调用`engine_start()`函数 (在`nemu/src/engine/interpreter/init.c`中定义). 代码会进入简易调试器(Simple Debugger)的主循环`sdb_mainloop()` (在`nemu/src/monitor/sdb/sdb.c`中定义)。

`strtok(str, " ")`使用空格将str字符串分为多个部分，若无结果则返回NULL，否则返回分割后的第一个字符串。之后，str会被存入静态缓冲区，下次要其他被分割字符时直接调用`strtok(NULL, " ")`。








