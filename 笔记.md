

# pa0

init之后`~/.bashrc`会自动添加（如果不从零开始的话可能得手动添加）：

```bash
export NEMU_HOME=/home/ayana/workspace/ics2023/nemu                         
export AM_HOME=/home/ayana/workspace/ics2023/abstract-machine
```

`make menuconfig`报错时执行：

```bash
sudo apt-get install bison
sudo apt-get install flex
```


# pa1

配置ccache的时候，只需在`~/.bashrc`加入：

```bash
#让ccache的软链接被提到PATH的最高优先级
export PATH="/usr/lib/ccache:$PATH" 
```

配置时会生成的重要文件包括：
- `nemu/include/generated/autoconf.h`, 阅读C代码时使用
- `nemu/include/config/auto.conf`, 阅读Makefile时使用

`$(CFLAGS)`值如下，是gcc编译的参数：

```bash
-O2 -MMD -Wall -Werror -I/home/user/ics2023/nemu/include
-I/home/user/ics2023/nemu/src/engine/interpreter -I/home/use
r/ics2023/nemu/src/isa/riscv32/include -O2    -D__GUEST_ISA__
=riscv32
```

>我们知道内存是一种RAM, 是一种易失性的存储介质, 这意味着计算机刚启动的时候, 内存中的数据都是无意义的; 而BIOS是固化在ROM/Flash中的, 它们都是非易失性的存储介质, BIOS中的内容不会因为断电而丢失.
 因此在真实的计算机系统中, 计算机启动后首先会把控制权交给BIOS, BIOS经过一系列初始化工作之后, 再从磁盘中将有意义的程序读入内存中执行. 对这个过程的模拟需要了解很多超出本课程范围的细节, 我们在PA中做了简化: 采取约定的方式让CPU直接从约定的内存位置开始执行.

>x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样, 例如mips32和riscv32的物理地址均从`0x80000000`开始. 因此对于mips32和riscv32, 其`CONFIG_MBASE`将会被定义成`0x80000000`. 将来CPU访问内存时, 我们会将CPU将要访问的内存地址映射到`pmem`中的相应偏移位置, 这是通过`nemu/src/memory/paddr.c`中的`guest_to_host()`函数实现的. 例如如果mips32的CPU打算访问内存地址`0x80000000`, 我们会让它最终访问`pmem[0]`, 从而可以正确访问客户程序的第一条指令. 这种机制有一个专门的名字, 叫地址映射, 在后续的PA中我们还会再遇到它.

## RTFSC

`init_monitor`：

```c
101 void init_monitor(int argc, char *argv[]) {
102   /* Perform some global initialization. */
103 
104   /* Parse arguments. */
105   parse_args(argc, argv);
106 
107   /* Set random seed. */
108   init_rand();
109 
110   /* Open the log file. */
111   init_log(log_file);
112 
113   /* Initialize memory. */
114   init_mem();
115 
116   /* Initialize devices. */
117   IFDEF(CONFIG_DEVICE, init_device());
118 
119   /* Perform ISA dependent initialization. */
120   init_isa();
121 
122   /* Load the image to memory. This will overwrite the built-in image. */
123   long img_size = load_img();
124 
125   /* Initialize differential testing. */
126   init_difftest(diff_so_file, img_size, difftest_port);
127 
128   /* Initialize the simple debugger. */
129   init_sdb();
130 
131 #ifndef CONFIG_ISA_loongarch32r
132   IFDEF(CONFIG_ITRACE, init_disasm(
133     MUXDEF(CONFIG_ISA_x86,     "i686",
134     MUXDEF(CONFIG_ISA_mips32,  "mipsel",
135     MUXDEF(CONFIG_ISA_riscv,
136       MUXDEF(CONFIG_RV64,      "riscv64",
137                                "riscv32"),
138                                "bad"))) "-pc-linux-gnu"
139   ));
140   #endif
141 
142   /* Display welcome message. */
143   welcome();
144 }
```

`load_img()`函数 (在`nemu/src/monitor/monitor.c`中定义)会将一个有意义的客户程序从[镜像文件](https://en.wikipedia.org/wiki/Disk_image)读入到内存, 覆盖刚才的内置客户程序. 这个镜像文件是运行NEMU的一个可选参数, 在运行NEMU的命令中指定. 如果运行NEMU的时候没有给出这个参数, NEMU将会运行内置客户程序.

Monitor的初始化工作结束后, `main()`函数会继续调用`engine_start()`函数 (在`nemu/src/engine/interpreter/init.c`中定义). 代码会进入简易调试器(Simple Debugger)的主循环`sdb_mainloop()` (在`nemu/src/monitor/sdb/sdb.c`中定义)。

`strtok(str, " ")`使用空格将str字符串分为多个部分，若无结果则返回NULL，否则返回分割后的第一个字符串。之后，str会被存入静态缓冲区，下次要其他被分割字符时直接调用`strtok(NULL, " ")`。

debug函数：

- `Log()`是`printf()`的升级版, 专门用来输出调试信息, 同时还会输出使用`Log()`所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置。`Log("Can not find sdcard image: %s", img);`
- `Assert()`是`assert()`的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息。`Assert(fp, "Can not open '%s'", img_file);`
- `panic()`用于输出信息并结束程序, 相当于无条件的assertion fail。`panic("unhandle offset = %d", offset);`

```c
 23 #define Log(format, ...) \
 24     _Log(ANSI_FMT("[%s:%d %s] " format, ANSI_FG_BLUE) "\n", \
 25         __FILE__, __LINE__, __func__, ## __VA_ARGS__)
 26 
 27 #define Assert(cond, format, ...) \
 28   do { \
 29     if (!(cond)) { \
 30       MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) "\n", ## __VA_ARGS__), \
 31         (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) "\n", ##  __VA_ARGS__))); \
 32       IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \
 33       extern void assert_fail_msg(); \
 34       assert_fail_msg(); \
 35       assert(cond); \
 36     } \
 37   } while (0)
 38 
 39 #define panic(format, ...) Assert(0, format, ## __VA_ARGS__)
 40 
 41 #define TODO() panic("please implement me")
```

>## __VA_ARGS__ 是宏定义中的可变参数部分。在宏定义中，__VA_ARGS__ 表示一个可变参数的占位符。## 是一个预处理器操作符，用于在宏展开时处理可变参数。  
  ## 的作用是将可变参数与前面的标识符（在这个例子中是 format）连接起来，以便在宏展开时形成一个完整的参数列表。这样可以使得宏在接受可变数量的参数时更加灵活。  

q时返回Error1的原因：main会调用src/utils/state.c:int is_exit_status_bad()，里面要求nemu_state.state要妥善处理，此时应当处理为NEMU_QUIT ：

```c
 20 int is_exit_status_bad() {
 21   int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) 
 22   || (nemu_state.state == NEMU_QUIT);              
 23   return !good;
 24 }
```

## 基础设施

|命令|格式|使用举例|说明|
|---|---|---|---|
|帮助(1)|`help`|`help`|打印命令的帮助信息|
|继续运行(1)|`c`|`c`|继续运行被暂停的程序|
|退出(1)|`q`|`q`|退出NEMU|
|单步执行|`si [N]`|`si 10`|让程序单步执行`N`条指令后暂停执行,  <br>当`N`没有给出时, 缺省为`1`|
|打印程序状态|`info SUBCMD`|`info r`  <br>`info w`|打印寄存器状态  <br>打印监视点信息|
|扫描内存(2)|`x N EXPR`|`x 10 $esp`|求出表达式`EXPR`的值, 将结果作为起始内存  <br>地址, 以十六进制形式输出连续的`N`个4字节|
|表达式求值|`p EXPR`|`p $eax + 1`|求出表达式`EXPR`的值, `EXPR`支持的  <br>运算请见[调试中的表达式求值](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/1.6.html)小节|
|设置监视点|`w EXPR`|`w *0x2000`|当表达式`EXPR`的值发生变化时, 暂停程序执行|
|删除监视点|`d N`|`d 2`|删除序号为`N`的监视点|


单步执行步数太大会导致无法输出状态。

```
(nemu) si 1
0x80000000: 00 00 02 97 auipc	t0, 0
(nemu) si 1
0x80000004: 00 02 88 23 sb	zero, 16(t0)
(nemu) si 1
0x80000008: 01 02 c5 03 lbu	a0, 16(t0)
(nemu) si 1
0x8000000c: 00 10 00 73 ebreak	
[src/cpu/cpu-exec.c:123 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000000c
[src/cpu/cpu-exec.c:88 statistic] host time spent = 303 us
[src/cpu/cpu-exec.c:89 statistic] total guest instructions = 4
[src/cpu/cpu-exec.c:90 statistic] simulation frequency = 13,201 inst/s
(nemu) q
```


















