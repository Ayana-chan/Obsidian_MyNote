


# 2023/10/24

看了1.5章帮助我简单地梳理了一下os的引导部分，其实和nju ics pa中学的大差不差，只是更符合现实了。


# 2023/10/25

由于bss段不占用存储空间，只会在运行时占内存，因此很适合用来塞栈。所以可以用全局变量来表示栈。

启动下一个应用程序时，相当于从trap中恢复，但要执行的是其他位置的应用程序，于是内核态给自己编造了一个context，然后走类似于trap恢复的路线。

trap一发生就保存发生后瞬间的sstatus+sepc的原因：
1. 兼容S->S的trap、此时s相关寄存器理所应当是上下文的一部分。
2. 其他异常可能不负责进行相关状态存储与恢复，导致状态丢失。

`__restore` 函数的起始部分会完成 sp←a0，而a0是函数的第一个参数。传参时若传了内核栈的栈顶，就使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。

`__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** （即把sp寄存器也作为状态的一部分进行更换或恢复）。


















