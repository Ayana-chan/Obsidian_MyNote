


# 2023/10/24

看了1.5章帮助我简单地梳理了一下os的引导部分，其实和nju ics pa中学的大差不差，只是更符合现实了。


# 2023/10/25

由于bss段不占用存储空间，只会在运行时占内存，因此很适合用来塞栈。所以可以用全局变量来表示栈。

启动下一个应用程序时，相当于从trap中恢复，但要执行的是其他位置的应用程序，于是内核态给自己编造了一个context，然后走类似于trap恢复的路线。

trap一发生就保存发生后瞬间的sstatus+sepc的原因：
1. 兼容S->S的trap、此时s相关寄存器理所应当是上下文的一部分。
2. 其他异常可能不负责进行相关状态存储与恢复，导致状态丢失。

`__restore` 函数的起始部分会完成 sp←a0，而a0是函数的第一个参数。传参时若传了内核栈的栈顶，就使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。

`__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** （即把sp寄存器也作为状态的一部分进行更换或恢复）。


# 2023/10/26

比较经典的多道程序与分时多任务。

在判断中断是否会被屏蔽的时候，有以下规则：
- 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
- 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽。

时间检测是基于计数器的，而非真的精确时间。

read到的是计数器，除以时钟频率就能得到时间。

set_next_trigger会计算10ms后应有的时钟频率，并将其设为触发器，到达此计数后就会触发中断。


# 2023/10/28

地址空间。

- 内碎片：已被分配出去（属于某个在运行的应用）内存区域，占有这些区域的应用并不使用这块区域（比如内存需求较少的应用占用了大体积的栈预留空间），操作系统也无法利用这块区域。
- 外碎片：还没被分配出去（不属于任何在运行的应用）内存空闲区域，由于太小而无法分配给提出申请内存空间的应用

`alloc::boxed::Box`和`alloc::vec::Vec`在完成内存分配机制后就能使用了。

39bit vddr -> 56bit pddr

页编号+页内偏移=唯一确定的地址

页表：虚拟页号到物理页号的映射。

使用虚拟页号在页表中查到的信息就是**页表项** (PTE, Page Table Entry)：物理页号和全部的标志位。

要构建27位虚拟号的索引，使用了Trie。27=9+9+9，每一级匹配9bit，匹配三层。匹配9bit就会产生$2^9$个分支，每个分支都是8Byte的指针或8Byte的页表项，因此每个结点都会存储刚好4KB的空间，刚好可以塞入一个物理页帧。寻找一个结点的一个分支的方式是：用该结点的物理页帧号转化为地址在加上对应的9bit数值，就得到了8Byte数据所在的地址。

内核有时候就需要访问真正的物理地址，但被MMU隔离后难以做到，于是就需要在给出vaddr的情况下知道其paddr。此时可以在内核层使用恒等映射，让vaddr和paddr恒等，从而让内核可以方便地修改目标物理内存。

data_frames（BTreeMap）会直接保存vaddr到paddr的映射。可见，三级页表树仅仅是为了更好地分配、修改，但依然允许直接存储映射。

特权级切换和地址空间切换是独立的，因此可以在内核态进行用户地址空间的访问。

call函数时，会直接被编译器弄成jr一个偏移量，在地址空间为用户、而状态为内核时，其行为会不正确。

trap.S是唯一涉及地址空间变换的代码段，因此将其放入按4K对齐的`.text.trampoline`段作为跳板。内核、用户的最高虚拟页都映射到了这段汇编，相当于让trap.S成为所有地址空间的汇集点，所有切换都由此发起。


# 2023/10/29

stvec依旧要以内核的形式设置trap入口，因为它是CPU使用的，是直接进入到对应的物理地址，也正对应着direct映射的内核虚拟地址。

每个地址空间都有一个页表，而这些页表共用一个物理地址分片器。

# 2023/10/30

对`translated_byte_buffer`相关功能做了进一步封装：
```rust
/// 将数据写入到buffer里面
pub fn write_byte_buffer<T>(ans: T, target: *mut T){
    let t_size = core::mem::size_of::<T>();
    let ans_slice = unsafe{
        core::slice::from_raw_parts(&ans as *const T as *const u8, t_size)
    };
    let aims = translated_byte_buffer(crate::task::current_user_token(),
        target as *const u8, t_size);
    
    let mut index: usize = 0;
    for _sub in aims{
        for aim_byte in _sub{
            *aim_byte = ans_slice[index];
            index += 1;
        }
    }
}
```

在内核初始化完毕之后会创建一个进程——即 **用户初始进程** (Initial Process) ，它是目前在内核中以硬编码方式创建的唯一一个进程。其他所有的进程都是通过一个名为 `fork` 的系统调用来创建的。







