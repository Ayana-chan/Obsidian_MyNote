


# 2023/10/24

看了1.5章帮助我简单地梳理了一下os的引导部分，其实和nju ics pa中学的大差不差，只是更符合现实了。


# 2023/10/25

由于bss段不占用存储空间，只会在运行时占内存，因此很适合用来塞栈。所以可以用全局变量来表示栈。

启动下一个应用程序时，相当于从trap中恢复，但要执行的是其他位置的应用程序，于是内核态给自己编造了一个context，然后走类似于trap恢复的路线。

trap一发生就保存发生后瞬间的sstatus+sepc的原因：
1. 兼容S->S的trap、此时s相关寄存器理所应当是上下文的一部分。
2. 其他异常可能不负责进行相关状态存储与恢复，导致状态丢失。

`__restore` 函数的起始部分会完成 sp←a0，而a0是函数的第一个参数。传参时若传了内核栈的栈顶，就使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。

`__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** （即把sp寄存器也作为状态的一部分进行更换或恢复）。


# 2023/10/26

比较经典的多道程序与分时多任务。

在判断中断是否会被屏蔽的时候，有以下规则：
- 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
- 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽。

时间检测是基于计数器的，而非真的精确时间。

read到的是计数器，除以时钟频率就能得到时间。

set_next_trigger会计算10ms后应有的时钟频率，并将其设为触发器，到达此计数后就会触发中断。


# 2023/10/28

地址空间。

- 内碎片：已被分配出去（属于某个在运行的应用）内存区域，占有这些区域的应用并不使用这块区域（比如内存需求较少的应用占用了大体积的栈预留空间），操作系统也无法利用这块区域。
- 外碎片：还没被分配出去（不属于任何在运行的应用）内存空闲区域，由于太小而无法分配给提出申请内存空间的应用

`alloc::boxed::Box`和`alloc::vec::Vec`在完成内存分配机制后就能使用了。

39bit vddr -> 56bit pddr

页编号+页内偏移=唯一确定的地址

页表：虚拟页号到物理页号的映射。

使用虚拟页号在页表中查到的信息就是**页表项** (PTE, Page Table Entry)：物理页号和全部的标志位。

要构建27位虚拟号的索引，使用了Trie。27=9+9+9，每一级匹配9bit，匹配三层。匹配9bit就会产生$2^9$个分支，每个分支都是8Byte的指针或8Byte的页表项，因此每个结点都会存储刚好4KB的空间，刚好可以塞入一个物理页帧。寻找一个结点的一个分支的方式是：用该结点的物理页帧号转化为地址在加上对应的9bit数值，就得到了8Byte数据所在的地址。

内核有时候就需要访问真正的物理地址，但被MMU隔离后难以做到，于是就需要在给出vaddr的情况下知道其paddr。此时可以在内核层使用恒等映射，让vaddr和paddr恒等，从而让内核可以方便地修改目标物理内存。

data_frames（BTreeMap）会直接保存vaddr到paddr的映射。可见，三级页表树仅仅是为了更好地分配、修改，但依然允许直接存储映射。

特权级切换和地址空间切换是独立的，因此可以在内核态进行用户地址空间的访问。

call函数时，会直接被编译器弄成jr一个偏移量，在地址空间为用户、而状态为内核时，其行为会不正确。

trap.S是唯一涉及地址空间变换的代码段，因此将其放入按4K对齐的`.text.trampoline`段作为跳板。内核、用户的最高虚拟页都映射到了这段汇编，相当于让trap.S成为所有地址空间的汇集点，所有切换都由此发起。


# 2023/10/29

stvec依旧要以内核的形式设置trap入口，因为它是CPU使用的，是直接进入到对应的物理地址，也正对应着direct映射的内核虚拟地址。

每个地址空间都有一个页表，而这些页表共用一个物理地址分片器。

# 2023/10/30

对`translated_byte_buffer`相关功能做了进一步封装：
```rust
/// 将数据写入到buffer里面
pub fn write_byte_buffer<T>(ans: T, target: *mut T){
    let t_size = core::mem::size_of::<T>();
    let ans_slice = unsafe{
        core::slice::from_raw_parts(&ans as *const T as *const u8, t_size)
    };
    let aims = translated_byte_buffer(crate::task::current_user_token(),
        target as *const u8, t_size);
    
    let mut index: usize = 0;
    for _sub in aims{
        for aim_byte in _sub{
            *aim_byte = ans_slice[index];
            index += 1;
        }
    }
}
```

在内核初始化完毕之后会创建一个进程——即 **用户初始进程** (Initial Process) ，它是目前在内核中以硬编码方式创建的唯一一个进程。其他所有的进程都是通过一个名为 `fork` 的系统调用来创建的。

父子进程创建的瞬间只有用来保存 `fork` 系统调用返回值的 a0 寄存器会不相同。

schedule是怎么调回`run_tasks`的？
>从源代码来看，切换回去之后，内核将跳转到 `run_tasks` 中 `__switch` 返回之后的位置，也即开启了下一轮的调度循环。

因为switch会记录调用它的进程的ra，以便在switch回来的时候能在上次switch之后继续执行。于是，idle switch出去又回来之后，进入loop的下一步，继续寻找新进程去switch。

进程1的U态->进程1的S态->switch->进程2的S态->进程2的U态

# 2023/10/31


内核切换进程时调用`suspend_current_and_run_next`，切换当前进程状态，并修改进程队列，然后才调用的schedule。

复制地址空间，就会复制每一个area，将复制的area插入到当前地址空间的时候就会自动分配物理页。然后对每个虚拟页，将原地址空间的物理页复制到当前地址空间中。

exec是直接对正在执行中的进程进行操作。执行完后由于context换新了，因此trap handler在设置返回值的时候要重新获取上下文引用。

一个进程终止或出错时，将其所有子进程设为初始进程的子进程。也会进行早期回收，应用地址空间的area列表被回收（即进程的数据和代码对应的物理页帧都被回收），但用来存放页表的那些物理页帧此时还不会被回收（会由父进程最后回收子进程剩余的占用资源）。

父进程一次`sys_waitpid`只回收一个zombie子进程。回收时，由于此时进程控制块是Arc指针构建是树，因此只要把父进程属下的该子进程从子进程列表中移出，就可以让其被释放。

spawn就是用类似exec的方式读取elf的数据+初始化上下文，用类似fork的方式新建进程，但其中被exec指定的数据就使用exec的。切忌用self的数据（父进程数据）来传给exec操作！

因为`STRIDE_MAX – STRIDE_MIN <= BigStride / 2`，所以若使用8bits存储stride、BigStride为255（8bit的最大值），则255/2 = 127，如果`a>b`但`a-b>127`的话，`Stride(a)<Stride(b)`。

Stride的Ord等实现中之所以不能有Equal出现，是为了防止被BTreeMap等数据结构去重。


# 2023/11/1

目录的r是访问，w是创建&删除，x是“通过”。与常规文件不同的是，用户无法 **直接** 修改目录的内容，只能通过创建/删除它下面的文件或子目录才能间接做到这一点。


# 2023/11/2

小块能管理大块的原因是：管理一个块只需要很小的一个数据标识。

每个文件/目录在磁盘上均以一个 `DiskInode` 的形式存储。
```rust
pub struct DiskInode {
    pub size: u32, //对应内容的字节数
    pub direct: [u32; INODE_DIRECT_COUNT], //索引
    pub indirect1: u32, //一级索引，指向存在数据块区域的一级索引块，一级索引块指向数据
    pub indirect2: u32, //二级索引，指向存在数据块区域的二级索引块，二级索引块指向一级索引块
    type_: DiskInodeType, //File or Directory
}
```

# 2023/11/4


读取文件的INode信息就是将磁盘中正确的位置上拷贝若干字节拼接成DiskInode放到内存中（使用DiskInode里面的方法），并将**DiskInode的这些方法**进一步封装在INode里，即vfs层；之后os再封装一层OSINode即可。

**每个文件/目录的索引节点在磁盘上均以一个 `DiskInode` 的形式存储**。而INode中调用read_disk_inode就能获取到对应的DiskInode（INode数据结构已经是vfs层了，并不是真实存储的东西）。

切记，目录的数据内容也存在数据区域里面，且存储方式是一堆连续的DirEntry。DiskInode提供了数据区域的block id，用于定位数据区域。

硬链接和解硬链接时，需要：
1. 改文件的DiskInode（索引区）以修改元数据（引用计数）
2. 改目录的目录项（数据区）以控制目录访问



