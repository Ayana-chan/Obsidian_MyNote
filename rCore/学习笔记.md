
# 相关

在./os下`make run BASE=2`即可带测例编译。

# 第零章 操作系统概述

操作系统与运行在用户态软件之间的接口形式就是**应用程序二进制接口 (ABI, Application Binary Interface)**。二进制的形式使其可以面向所有编程语言。

![](assets/uTools_1691937208248.png)

![400](assets/uTools_1691812931287.png)

内核主要组成部分：
1. 进程/线程管理：内核负责管理系统中的进程或线程，创建、销毁、调度和切换进程或线程。
2. 内存管理：内核负责管理系统的内存，分配和回收内存空间，并保证进程之间的内存隔离。
3. 文件系统：内核提供文件系统接口，负责管理存储设备上的文件和目录，并允许应用访问文件系统。
4. 网络通信：内核提供网络通信接口，负责管理网络连接并允许应用进行网络通信。
5. 设备驱动：内核提供设备驱动接口，负责管理硬件设备并允许应用和内核其他部分访问设备。
6. 同步互斥：内核负责协调多个进程或线程之间对共享资源的访问。同步功能主要用于解决进程或线程之间的协作问题，互斥功能主要用于解决进程或线程之间的竞争问题。
7. 系统调用接口：内核提供给应用程序访问系统服务的入口，应用程序通过系统调用接口调用操作系统提供的服务，如文件系统、网络通信、进程管理等。

![](assets/uTools_1691813186320.png)

>脱机方式（offline mode）
 基于脱机方式的操作是指没有与计算机进行关联所完成的操作。比如把包含程序的卡片放到卡片机上，把打印纸安装到打印机上等。与此相反的是联机方式（online mode）的操作，即通过与计算机相联所完成的操作，比如计算机把正在运行的应用程序所计算出来的结果通过打印机打印到纸上。
 现在，脱机方式的操作更多的是指断网下进行的操作，联机方式是指在联网下进行的操作。

目前 Linux 有超过三百个的**系统调用接口(System Call Interface)**。下面列出了一些相对比较重要的操作系统接口或抽象，以及它们的大致功能：
- 进程（即程序运行过程）管理：复制创建进程 fork 、退出进程 exit 、执行进程 exec 等。
- 线程管理：线程（即程序的一个执行流）的创建、执行、调度切换等。
- 线程同步互斥的并发控制：互斥锁 mutex 、信号量 semaphore 、管程 monitor 、条件变量 condition variable 等。
- 进程间通信：管道 pipe 、信号 signal 、事件 event 等。
- 虚存管理：内存空间映射 mmap 、改变数据段地址空间大小 sbrk 、共享内存 shm 等。
- 文件 I/O 操作：对存储设备中的文件进行读 read 、写 write 、打开 open 、关闭 close 等操作。
- 外设 I/O 操作：外设包括键盘、显示器、串口、磁盘、时钟 … ，主要采用文件 I/O 操作接口。

抽象概念：
- 文件 (File) 是外设的一种抽象和虚拟化。特别对于存储外设而言，文件是持久存储的抽象。
- 地址空间 (Address Space) 是对内存的抽象和虚拟化。
- 进程 (Process) 是对计算机资源的抽象和虚拟化。而其中最核心的部分是对 CPU 的抽象与虚拟化

![400](assets/uTools_1691936024815.png)

![](assets/uTools_1691937556204.png)

- 物理资源：即计算机硬件资源，如CPU的寄存器、可访问的物理内存等。
- 虚拟资源：即操作系统提供的资源，如文件，网络端口号，网络地址，信号等。

在操作系统中，需要处理三类**异常控制流**：外设**中断** (Device Interrupt) 、**陷入** (Trap) 和**异常** (Exception，也称Fault Interrupt)。

进程上下文：

![500](assets/uTools_1692003020894.png)

文件：

![](assets/uTools_1692003763707.png)


# 第一章 应用程序与基本执行环境

![](assets/uTools_1692079341325.png)

![](assets/uTools_1698125802902.png)

指定交叉编译（target必须是编译器支持的，可以通过`rustup target add riscv64gc-unknown-none-elf`来安装，用`rustc --print target-list`查询已支持的）：
```config
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

riscv的拓展可以看成功能模块，多一个拓展就多一个功能。

去掉标准库之后，依然可以使用core库。core库不依赖于os，放哪里都能用。

通过编写链接配置文件，把代码段中的入口函数放在最低地址，即可让内存载入的时候起始点就是入口函数。前提是丢弃了没用的元数据，不然起始点可能是元数据而非可执行内容。

- **被调用者保存(Callee-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变；
- **调用者保存(Caller-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变

- sp会被被调用者自行分配、回收、管理，因此是被调用者保存寄存器。
- ra是在被调用者调用结束后进行跳转的目标，因此也是被调用者保存寄存器。
- fp用于被调用者结束后释放栈空间，因此也是被调用者保存寄存器。

>当前执行函数的栈帧的两个边界分别由栈指针 (Stack Pointer, sp(x2))寄存器和栈帧指针（frame pointer,  fp(s0)）寄存器来限定。

栈帧中有：
- `ra` 寄存器保存其返回之后的跳转地址，是一个被调用者保存寄存器；
- 父亲栈帧的结束地址 `fp` ，是一个被调用者保存寄存器；
- 其他被调用者保存寄存器 `s1` ~ `s11` ；
- 函数所使用到的局部变量。
![](assets/uTools_1698128364987.png)

函数调用：
```asmb
# 开场
# 为当前函数分配 64 字节的栈帧
addi        sp, sp, -64
# 将 ra 和 fp 压栈保存
sd  ra, 56(sp)
sd  s0, 48(sp)
# 更新 fp 为当前函数栈帧顶端地址
addi        s0, sp, 64

# 函数执行
# 中间如果再调用了其他函数会修改 ra

# 结尾
# 恢复 ra 和 fp
ld  ra, 56(sp)
ld  s0, 48(sp)
# 退栈
addi        sp, sp, 64
# 返回，使用 ret 指令或其他等价的实现方式
ret
```

可以通过使用space来让栈段直接申请一定的内存，这也可以很方便地检测是否栈溢出。
```asmb
 1# os/src/entry.asm
 2    .section .text.entry
 3    .globl _start
 4_start:
 5    la sp, boot_stack_top # 初始化sp
 6    call rust_main # 入口函数
 7
 8    .section .bss.stack # stack位于.bss.stack段
 9    .globl boot_stack_lower_bound
10boot_stack_lower_bound:
11    .space 4096 * 16 #栈空间
12    .globl boot_stack_top
13boot_stack_top:
```

>全局符号 `sbss` 和 `ebss` 来自于链接脚本，分别指向 `.bss` 段除 `.bss.stack` 以外的起始和终止地址，即指出需要被清零的 `.bss` 段的起始和终止地址，我们在使用这部分数据之前需要将它们初始化为零

通过函数名的方式来获得链接脚本中的符号位置：
```rust
extern "C" {
    fn sbss();
    fn ebss();
}
```


# 第二章 批处理系统

![](assets/uTools_1698134401117.png)

为了让应用程序获得操作系统的函数服务，采用传统的函数调用方式（即通常的 `call` 和 `ret` 指令或指令组合）将会直接绕过硬件的特权级保护检查。所以可以设计新的机器指令：执行环境调用（Execution Environment Call，简称 `ecall` ）和执行环境返回(Execution Environment Return，简称 `eret` )）：
- `ecall` ：具有用户态到内核态的执行环境切换能力的函数调用指令
- `eret` ：具有内核态到用户态的执行环境切换能力的函数返回指令

![400](assets/uTools_1698135926246.png)

>运行在 M 模式上的软件被称为 **监督模式执行环境** (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行

执行 `ecall` 这条指令时候则会随着 CPU 当前所处特权级而触发不同的异常，当 CPU 分别处于 M/S/U 三种特权级时执行 `ecall` 这条指令会触发三种异常。

M 模式软件 SEE 和 S 模式的内核之间的接口被称为 **监督模式二进制接口** (Supervisor Binary Interface, SBI)，而内核和 U 模式的应用程序之间的接口被称为 **应用程序二进制接口** (Application Binary Interface, ABI)，当然它有一个更加通俗的名字—— **系统调用** (syscall, System Call) 。

![](assets/uTools_1698138305266.png)

mret在M中用，sret在S中用。

S模式特权指令：

|指令|含义|
|---|---|
|sret|从 S 模式返回 U 模式：在 U 模式下执行会产生非法指令异常|
|wfi|处理器在空闲时进入低功耗状态等待中断：在 U 模式下执行会产生非法指令异常|
|sfence.vma|刷新 TLB 缓存：在 U 模式下执行会产生非法指令异常|
|访问 S 模式 CSR 的指令|通过访问 [sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 来改变系统状态：在 U 模式下执行会产生非法指令异常|

>CPU 对物理内存所做的缓存又分成 **数据缓存** (d-cache) 和 **指令缓存** (i-cache) 两部分，分别在 CPU 访存和取指的时候使用。在取指的时候，对于一个指令地址， CPU 会先去 i-cache 里面看一下它是否在某个已缓存的缓存行内，如果在的话它就会直接从高速缓存中拿到指令而不是通过总线访问内存。通常情况下， CPU 会认为程序的代码段不会发生变化，因此 i-cache 是一种只读缓存。但在这里，OS 将修改会被 CPU 取指的内存区域，这会使得 i-cache 中含有与内存中不一致的内容。因此， OS 在这里必须使用取指屏障指令 `fence.i` ，它的功能是保证 **在它之后的取指过程必须能够看到在它之前的所有对于取指内存区域的修改** ，这样才能保证 CPU 访问的应用代码是最新的而不是 i-cache 中过时的内容。

AEE（Application Execution Environment)

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 `stvec` 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，上面 提到过我们必须保存原控制流的寄存器状态，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而不是应用程序运行时用到的用户栈。

由于bss段不占用存储空间，只会在运行时占内存，因此很适合用来塞栈。所以可以用全局变量来表示栈。

>换栈是非常简单的，只需将 `sp` 寄存器的值修改为 `get_sp` 的返回值即可。

上下文：
```rust
4pub struct TrapContext {
5    pub x: [usize; 32],
6    pub sstatus: Sstatus,
7    pub sepc: usize,
8}
```

trap时会直接保存上下文到栈中，包括用户的状态和trap处理时的状态。

启动下一个应用程序时，相当于从trap中恢复，但要执行的是其他位置的应用程序，于是内核态给自己编造了一个context，然后走类似于trap恢复的路线。

`__restore` 函数的起始部分会完成 sp←a0，而a0是函数的第一个参数。传参时若传了内核栈的栈顶，就使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。

# 第三章 多道程序和分时多任务

**多道程序** (Multiprogramming) 和 **分时多任务** (Time-Sharing Multitasking)

锯齿螈**多道程序**操作系统 - Multiprog OS（轮流执行）：
![](assets/uTools_1698223642896.png)

始初龙**协作式多道程序**操作系统 – CoopOS（主动放弃）：
![](assets/uTools_1698224271221.png)

腔骨龙**分时多任务**操作系统 – TimesharingOS（时钟中断）：
![](assets/uTools_1698224401893.png)

把应用程序的一次执行过程（也是一段控制流）称为一个 **任务** ，把应用执行过程中的一个时间片段上的执行片段或空闲片段称为 “ **计算任务片** ” 或“ **空闲任务片** ” 。当应用程序的所有任务片都完成后，应用程序的一次任务也就完成了。从一个程序的任务切换到另外一个程序的任务称为 **任务切换** 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。

所有任务的task-context放在os的数据段中，若一个task不在执行，则其上下文都被保存在对应位置。

`__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** （即把sp寄存器也作为状态的一部分进行更换或恢复）。

**主动** 调用 `sys_yield` 系统调用意味着应用主动交出 CPU 的使用权给其他应用。

![](assets/uTools_1698236547397.png)

调度算法需要考虑：每次在换出之前给一个应用多少时间片去执行，以及要换入哪个应用。可以从性能（主要是吞吐量和延迟两个指标）和 **公平性** (Fairness) 两个维度来评价调度算法，后者要求多个应用分到的时间片占比不应差距过大。

目前使用**时间片轮转算法** (RR, Round-Robin) 来对应用进行调度。

在判断中断是否会被屏蔽的时候，有以下规则：
- 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
- 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽。

以内核所在的 S 特权级为例，中断屏蔽相应的 CSR 有 `sstatus` 和 `sie` 。`sstatus` 的 `sie` 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 `sstatus.sie` 置 1 ，还要看 `sie` 这个 CSR，它的三个字段 `ssie/stie/seie` 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 `sstatus.sie` 和 `sie.stie` 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。

如果中断没有被屏蔽，那么接下来就需要软件进行处理，而具体到哪个特权级进行处理与一些中断代理 CSR 的设置有关。默认情况下，所有的中断都需要到 M 特权级处理。而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，但是 Trap 到的特权级不能低于中断的特权级。事实上所有的中断/异常默认也都是到 M 特权级处理的。

>嵌套中断可以分为两部分：在处理一个中断的过程中又被同特权级/高特权级中断所打断。默认情况下硬件会避免同特权级再次发生，但高特权级中断则是不可避免的会再次发生。
 嵌套 Trap 则是指处理一个 Trap（可能是中断或异常）的过程中又再次发生 Trap ，嵌套中断是嵌套 Trap 的一个特例。在内核开发时我们需要仔细权衡哪些嵌套 Trap 应当被允许存在，哪些嵌套 Trap 又应该被禁止，这会关系到内核的执行模型

read到的是计数器，除以时钟频率就能得到时间。

set_next_trigger会计算10ms后应有的时钟频率，并将其设为触发器，到达此计数后就会触发中断。

我们并没有将应用初始 Trap 上下文中的 `sstatus` 中的 `SPIE` 位置为 1 。这将意味着 CPU 在用户态执行应用的时候 `sstatus` 的 `SIE` 为 0 ，根据定义来说，此时的 CPU 会屏蔽 S 态所有中断，自然也包括 S 特权级时钟中断。但是可以观察到我们的应用在用尽一个时间片之后能够正常被打断。这是因为<u>当 CPU 在 U 态接收到一个 S 态时钟中断时会被抢占</u>，这时无论 `SIE` 位是否被设置都会进入 Trap 处理流程


# 第四章 地址空间

>user下的build.py被移除了

![](assets/uTools_1698385100594.png)

- 内碎片：已被分配出去（属于某个在运行的应用）内存区域，占有这些区域的应用并不使用这块区域（比如内存需求较少的应用占用了大体积的栈预留空间），操作系统也无法利用这块区域。
- 外碎片：还没被分配出去（不属于任何在运行的应用）内存空闲区域，由于太小而无法分配给提出申请内存空间的应用

如果要在操作系统内核中支持动态内存分配，则需要实现在本节开始介绍的一系列功能：初始化堆、分配/释放内存块的函数接口、连续内存分配算法。相对于 C 语言而言，Rust语言在 `alloc` crate 中设定了一套简洁规范的接口，只要实现了这套接口，内核就可以很方便地支持动态内存分配了。

>TODO：理解：
>**为何 C 语言 malloc 的时候不需要提供对齐需求？**
 在 C 语言中，所有对齐要求的最大值是一个平台相关的常数（比如 8 bytes），消耗少量内存即可使得每一次分配都符合这个最大的对齐要求。因此也就不需要区分不同分配的对齐要求了。而在 Rust 中，某些分配的对齐要求的值可能很大，就只能采用更加复杂的方法。

`alloc::boxed::Box`和`alloc::vec::Vec`。

每个应用的地址空间中都预留了一部分空间用于动态内存分配（位于每个应用的全局数据段`.data`段中）。

当 CPU 取指令或者执行一条访存指令的时候，它都是基于虚拟地址访问属于当前正在运行的应用的地址空间。此时，CPU 中的 **内存管理单元** (MMU, Memory Management Unit) 自动将这个虚拟地址进行 **地址转换** (Address Translation) 变为一个物理地址，即这个应用的数据/指令的物理内存位置。也就是说，在 MMU 的帮助下，应用对自己虚拟地址空间的读写才能被实际转化为对于物理内存的访问。
![](assets/uTools_1698458625782.png)


内核始终以一个同样大小的单位来在物理内存上放置应用地址空间中的数据，这样内核就可以使用简单的插槽式内存管理，使得内存分配算法比较简单且**不会产生外碎片**；同时，这个单位的大小要足够小，从而其内部没有被用到的内碎片的大小也足够小，尽可能提高内存利用率，**减少内碎片大小**。这便是我们将要介绍的**分页内存管理**。

![](assets/uTools_1698459210513.png)

当一个应用的地址空间比较大的时候，页表中的项数会很多（事实上每个虚拟页面都应该对应页表中的一项，上图中我们已经省略掉了那些未被使用的虚拟页面），导致它的容量极速膨胀，已经不再是像之前那样数个寄存器便可存下来的了，CPU 内也没有足够的硬件资源能够将它存下来。因此它只能**作为一种被内核管理的数据结构放在内存中**，但是 CPU 也会直接访问它来查页表，这也就需要内核和硬件之间关于页表的内存布局达成一致。

satp寄存器存储了地址映射的相关配置。分为三个字段：
- `MODE` 控制 CPU 使用哪种页表实现；
- `ASID` 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；
- `PPN` 存的是根页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号。

39bit vddr -> 56bit pddr

TODO：理解：实际上无论是虚拟地址还是物理地址，真正有意义、能够通过 MMU 的地址转换或是 CPU 内存控制单元的检查的地址仅占其中的很小一部分，因此它们（访问范围）的理论容量上限在目前都没有实际意义。

页编号+页内偏移=唯一确定的地址

![](assets/uTools_1698460828504.png)

>在 64 位架构上虚拟地址长度确实应该和位宽一致为 64 位，但是在启用 SV39 分页模式下，只有低 39 位是真正有意义的。SV39 分页模式规定 64 位虚拟地址的 [63:39] 这 25 位必须和第 38 位相同，否则 MMU 会直接认定它是一个不合法的虚拟地址。通过这个检查之后 MMU 再取出低 39 位尝试将其转化为一个 56 位的物理地址。
 也就是说，所有 264 个虚拟地址中，只有最低的 256GiB （当第 38 位为 0 时）以及最高的 256GiB （当第 38 位为 1 时）是可能通过 MMU 检查的。当我们写软件代码的时候，一个地址的位宽毋庸置疑就是 64 位，我们要清楚可用的只有最高和最低这两部分，尽管它们已经巨大的超乎想象了；而本节中我们专注于介绍 MMU 的机制，强调 MMU 看到的真正用来地址转换的虚拟地址只有 39 位。

页表：虚拟页号到物理页号的映射。

从物理页号到物理地址的转换只需左移 12 位即可，但是物理地址需要保证它与页面大小对齐才能通过右移转换为物理页号。

使用虚拟页号在页表中查到的信息就是**页表项** (PTE, Page Table Entry)：物理页号和全部的标志位。

![](assets/uTools_1698463840690.png)

- V(Valid)：仅当位 V 为 1 时，页表项才是合法的；
- R(Read)/W(Write)/X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行；
- U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
- G：暂且不理会；
- A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
- D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过。

虚页号（Virtial Page Number， VPN）

使用这种映射方法的一个缺点就是要给所有的页都设一个页表项。因此，必须**按需分配**：刚开始不存任何页表项，让所有虚拟地址全部非法；当内核已经决定好了一个应用的各逻辑段存放位置之后，它就需要负责从零开始以虚拟页面为单位来让该应用的地址空间的某些部分变得合法，反映在该应用的页表上也就是一对对映射顺次被插入进来，自然页表所占据的内存大小也就逐渐增加。

要构建27位虚拟号的索引，使用了Trie。27=9+9+9，每一级匹配9bit，匹配三层。匹配9bit就会产生$2^9$个分支，每个分支都是8Byte，为页表项或者是带标志位的指针（56位物理地址+8位标志位），因此每个结点都会存储刚好4KB的空间，刚好可以塞入一个物理页帧。寻找一个结点的一个分支的方式是：用该结点的物理页帧号转化为地址在加上对应的9bit数值，就得到了8Byte数据所在的地址。

具体来说，假设我们有虚拟地址 $(VPN0,VPN1,VPN2,offset)$ ：
- 我们首先会记录装载「当前所用的一级页表的物理页」的页号到 satp 寄存器中；
- 把 VPN0 作为偏移在一级页表的物理页中找到二级页表的物理页号；
- 把 VPN1 作为偏移在二级页表的物理页中找到三级页表的物理页号；
- 把 VPN2 作为偏移在三级页表的物理页中找到要访问位置的物理页号；
- 物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址。

>注意本书将多级页表的根节点称为一级页表，在其他地方则可能以相反的顺序将根节点称为三级页表，这只是表述的习惯不同。

- 当 `V` 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的；
- 只有当 `V` 为1 且 `R/W/X` 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表；
- 注意: 当 `V` 为1 且 `R/W/X` 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号。


实践表明绝大部分应用程序的虚拟地址访问过程具有时间局部性和空间局部性的特点，因此用MMU中的 **快表（TLB, Translation Lookaside Buffer）**（在CPU里） 来作为虚拟页号到物理页号的映射的页表缓存。

但如果修改了 satp 寄存器，说明内核切换到了一个与先前映射方式完全不同的页表。此时快表里面存储的映射已经失效了，这种情况下内核要在修改 satp 的指令后面马上使用 sfence.vma 指令刷新清空整个 TLB。

同样，我们手动修改一个页表项之后，也修改了映射，但 TLB 并不会自动刷新清空，我们也需要使用 sfence.vma 指令刷新整个 TLB。注：可以在 sfence.vma 指令后面加上一个虚拟地址，这样 sfence.vma 只会刷新TLB中关于这个虚拟地址的单个映射项。

在分配 `alloc` 的时候，首先会检查栈 `recycled` 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间$[current,end)$ 上进行分配，我们分配它的左端点 `current` ，同时将管理器内部维护的 `current` 加 `1` 代表 `current` 已被分配了。回收的页号必然是以前分配过的，这需要进行验证。这实现了类似于堆的访问接口。

内核有时候就需要访问真正的物理地址，但被MMU隔离后难以做到，于是就需要在给出vaddr的情况下知道其paddr。此时可以在内核层使用恒等映射，让vaddr和paddr恒等，从而让内核可以方便地修改目标物理内存。

`Identical` 表示上一节提到的恒等映射方式；而 `Framed` 则表示对于每个虚拟页面都有一个新分配的物理页帧与之对应，虚地址与物理地址的映射关系是相对随机的。恒等映射方式主要是用在启用多级页表之后，内核仍能够在虚存地址空间中访问一个特定的物理地址指向的物理内存。

**逻辑段（MapArea）**：一段连续地址的虚拟内存，该区间内包含的所有虚拟页面都以一种相同的方式（`Identical`或`Framed`）映射到物理页帧。
```rust
pub struct MapArea {
    vpn_range: VPNRange,
    data_frames: BTreeMap<VirtPageNum, FrameTracker>,
    map_type: MapType,
    map_perm: MapPermission,
}
```

data_frames（BTreeMap）会直接保存vaddr到paddr的映射。可见，三级页表树仅仅是为了更好地分配、修改，但依然允许直接存储映射。

**地址空间（MemorySet）**：一系列有关联的不一定连续的逻辑段，这种关联一般是指这些逻辑段组成的虚拟内存空间与一个运行的程序（目前把一个运行的程序称为任务，后续会称为进程）绑定，即这个运行的程序对代码和数据的直接访问范围限制在它关联的虚拟地址空间之内。保证同一地址空间内的任意两个逻辑段不能存在交集。
```rust
pub struct MemorySet {
    page_table: PageTable,
    areas: Vec<MapArea>,
}
```

内核地址空间中，高256GB放跳板和应用的内核栈，中间插入**保护页面(Guard Page)**。低256GB放内核程序相关的段。

![500](assets/uTools_1698489899995.png)

![400](assets/uTools_1698489911870.png)

应用地址空间的低256GB存储程序相关段，和一个栈。高256GB存储了跳板和trap上下文。

![](assets/uTools_1698489927144.png)

内核可以通过查页表来得知应用所在的地址以进行访问，使得内核层可以干涉应用层。

为了防止切换内核态的时候破坏通用寄存器使得trap context保存不正常，于是在切换内核态之前保存，因此会保存到用户态的地址空间中。

特权级切换和地址空间切换是独立的，因此可以在内核态进行用户地址空间的访问。

call函数时，会直接被编译器弄成jr一个偏移量，在地址空间为用户、而状态为内核时，其行为会不正确。

trap.S是唯一涉及地址空间变换的代码段，因此将其放入按4K对齐的`.text.trampoline`段作为跳板。内核、用户的最高虚拟页都映射到了这段汇编，而且映射的虚拟地址都是完全一样的，相当于让trap.S成为所有地址空间的共识汇集点，所有切换都由此发起。（注：似乎CPU访问PC时也会查询MMU？）

stvec依旧要以内核的形式设置trap入口，因为它是CPU使用的，是直接进入到对应的物理地址，也正对应着direct映射的内核虚拟地址。

translated_byte_buffer会返回在内核地址空间中零散的目标内存区域，返回类型是`Vec<&mut [u8]>`。

每个进程都有一个地址空间，地址空间里面有页表。TaskControlBlock里面存储了地址空间信息。

insert_framed_area可以将一些新的连续页作为新area进行插入。

对`translated_byte_buffer`相关功能做了进一步封装：
```rust
/// 将数据写入到buffer里面
pub fn write_byte_buffer<T>(ans: T, target: *mut T){
    let t_size = core::mem::size_of::<T>();
    let ans_slice = unsafe{
        core::slice::from_raw_parts(&ans as *const T as *const u8, t_size)
    };
    let aims = translated_byte_buffer(crate::task::current_user_token(),
        target as *const u8, t_size);
    
    let mut index: usize = 0;
    for _sub in aims{
        for aim_byte in _sub{
            *aim_byte = ans_slice[index];
            index += 1;
        }
    }
}
```


# 第五章 进程

![](assets/uTools_1698653431932.png)

- sys_fork：创建子进程
- sys_waitpid：等待子进程结束并回收子进程资源
- sys_exec：用新的应用内容覆盖当前进程，即达到执行新应用的目的

![](assets/uTools_1698653983411.png)

**进程** (Process) 的含义是 **在操作系统管理下的程序的一次执行过程**。

在内核初始化完毕之后会创建一个进程——即 **用户初始进程** (Initial Process) ，它是目前在内核中以硬编码方式创建的唯一一个进程。其他所有的进程都是通过一个名为 `fork` 的系统调用来创建的。

父子进程创建的瞬间只有用来保存 `fork` 系统调用返回值的 a0 寄存器会不相同。

注意到每个进程可能有多个子进程，但最多只能有一个父进程，于是所有进程可以被组织成一颗树，其根节点正是代表用户初始程序——initproc，也即第一个用户态的初始进程。

如果一个进程先于它的子进程结束，在它退出的时候，它的所有子进程将成为进程树的根节点——用户初始进程的子进程，同时这些子进程的父进程也会转成用户初始进程。这之后，**这些子进程的资源就由用户初始进程负责回收了**，这也是用户初始进程很重要的一个用途。

>注意我们需要在`exec("user_shell\0");`字符串末尾手动加入 `\0` ，因为 Rust 在将这些字符串连接到只读数据段的时候不会插入 `\0` 。

输出`BS 0x08u8`符号即可实现退格。

由于资源都是按进程分配的，因此原来的应用编号现在都要换成进程号。

kernel_stack是连续分配的，仅存在一个area，因此得知kernel_stack的最低位时就能根据该位释放整个area。

TODO：内核的动态分配区域在哪里？内核初始化时使用的启动栈在哪里？

当需要调度进程时，内核调用schedule，而它会switch出idle控制流，而idle又会选择下一个要执行的进程，然后switch过去。这保证了调度逻辑对trap透明。应用trap到内核后，内核只需要决定是否需要换下一个任务，然后全权交给idle。idle的上下文一直是初始0，应该没有实际意义。
>使得换入/换出进程和调度执行流在内核层各自执行在不同的内核栈上，分别是**进程自身的内核栈**和**内核初始化时使用的启动栈**。这样的话，调度相关的数据不会出现在进程内核栈上，也使得调度机制对于换出进程的Trap执行流是不可见的。

schedule是怎么调回`run_tasks`的？
>从源代码来看，切换回去之后，内核将跳转到 `run_tasks` 中 `__switch` 返回之后的位置，也即开启了下一轮的调度循环。

因为switch会记录调用它的进程的ra，以便在switch回来的时候能在上次switch之后继续执行。于是，idle switch出去又回来之后，进入loop的下一步，继续寻找新进程去switch。

进程1的U态->进程1的S态->switch->进程2的S态->进程2的U态

内核切换进程时调用`suspend_current_and_run_next`，切换当前进程状态，并修改进程队列，然后才调用的schedule。

复制地址空间，就会复制每一个area，将复制的area插入到当前地址空间的时候就会自动分配物理页。然后对每个虚拟页，将原地址空间的物理页复制到当前地址空间中。

exec是直接对正在执行中的进程进行操作。执行完后由于context换新了，因此trap handler在设置返回值的时候要重新获取上下文引用。

一个进程终止或出错时，将其所有子进程设为初始进程的子进程。也会进行早期回收，应用地址空间的area列表被回收（即进程的数据和代码对应的物理页帧都被回收），但用来存放页表的那些物理页帧此时还不会被回收（会由父进程最后回收子进程剩余的占用资源）。

父进程一次`sys_waitpid`只回收一个zombie子进程。回收时，由于此时进程控制块是Arc指针构建是树，因此只要把父进程属下的该子进程从子进程列表中移出，就可以让其被释放。

>利用 `git cherry-pick` 系列指令，能方便地将前一章分支 commit 移植到本章分支。

spawn就是用类似exec的方式读取elf的数据+初始化上下文，用类似fork的方式新建进程，但其中被exec指定的数据就使用exec的。切忌用self的数据（父进程数据）来传给exec操作！

因为`STRIDE_MAX – STRIDE_MIN <= BigStride / 2`，所以若使用8bits存储stride、BigStride为255（8bit的最大值），则255/2 = 127，如果`a>b`但`a-b>127`的话，`Stride(a)<Stride(b)`。

![](assets/uTools_1698763933027.png)

要把文件访问相关的系统调用与easyfs文件系统连接起来。在easfs文件系统中是没有进程的概念的。而进程是程序运行过程中访问资源的管理实体，而之前的进程没有管理文件这种资源。 为此我们需要扩展进程的管理范围，把文件也纳入到进程的管理之中。 由于我们希望多个进程都能访问文件，这意味着文件有着共享的天然属性，这样自然就有了``open/close/read/write``这样的系统调用，便于进程通过互斥或共享方式访问文件。

# 第六章 文件系统

目录的r是访问，w是创建&删除，x是“通过”。与常规文件不同的是，用户无法 **直接** 修改目录的内容，只能通过创建/删除它下面的文件或子目录才能间接做到这一点。

在一个计算机系统中，可以同时包含多个持久存储设备，它们上面的数据可能是以不同文件系统格式存储的。为了能够对它们进行统一管理，在内核中有一层 **虚拟文件系统** (VFS, Virtual File System) ，它规定了逻辑上目录树结构的通用格式及相关操作的抽象接口，只要不同的底层文件系统均实现虚拟文件系统要求的那些抽象接口，再加上 **挂载** (Mount) 等方式，这些持久存储设备上的不同文件系统便可以用一个统一的逻辑目录树结构一并进行管理。

`easy-fs` crate 自下而上大致可以分成五个不同的层次：

1. 磁盘块设备接口层：定义了以块大小为单位对磁盘块设备进行读写的trait接口
2. 块缓存层：在内存中缓存磁盘块的数据，避免频繁读写磁盘
3. 磁盘数据结构层：磁盘上的超级块、位图、索引节点、数据块、目录项等核心数据结构和相关处理
4. 磁盘块管理器层：合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构，以及基于这些结构的创建/打开文件系统的相关处理和磁盘块的分配和回收处理
5. 索引节点层：管理索引节点（即文件控制块）数据结构，并实现文件创建/文件打开/文件读写等成员函数来向上支持文件操作相关的系统调用

在 `easy-fs` 中并没有一个实现了 `BlockDevice` Trait 的具体类型。因为块设备仅支持以块为单位进行随机读写，所以需要由具体的块设备驱动来实现这两个方法，实际上这是需要由文件系统的使用者（比如操作系统内核或直接测试 `easy-fs` 文件系统的 `easy-fs-fuse` 应用程序）提供并接入到 `easy-fs` 库的。 `easy-fs` 库的块缓存层会调用这两个方法，进行块缓存的管理。这也体现了 `easy-fs` 的泛用性：它可以访问实现了 `BlockDevice` Trait 的块设备驱动程序。





