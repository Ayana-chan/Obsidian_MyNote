
# 第零章 操作系统概述

操作系统与运行在用户态软件之间的接口形式就是**应用程序二进制接口 (ABI, Application Binary Interface)**。二进制的形式使其可以面向所有编程语言。

![](assets/uTools_1691937208248.png)

![400](assets/uTools_1691812931287.png)

内核主要组成部分：
1. 进程/线程管理：内核负责管理系统中的进程或线程，创建、销毁、调度和切换进程或线程。
2. 内存管理：内核负责管理系统的内存，分配和回收内存空间，并保证进程之间的内存隔离。
3. 文件系统：内核提供文件系统接口，负责管理存储设备上的文件和目录，并允许应用访问文件系统。
4. 网络通信：内核提供网络通信接口，负责管理网络连接并允许应用进行网络通信。
5. 设备驱动：内核提供设备驱动接口，负责管理硬件设备并允许应用和内核其他部分访问设备。
6. 同步互斥：内核负责协调多个进程或线程之间对共享资源的访问。同步功能主要用于解决进程或线程之间的协作问题，互斥功能主要用于解决进程或线程之间的竞争问题。
7. 系统调用接口：内核提供给应用程序访问系统服务的入口，应用程序通过系统调用接口调用操作系统提供的服务，如文件系统、网络通信、进程管理等。

![](assets/uTools_1691813186320.png)

>脱机方式（offline mode）
 基于脱机方式的操作是指没有与计算机进行关联所完成的操作。比如把包含程序的卡片放到卡片机上，把打印纸安装到打印机上等。与此相反的是联机方式（online mode）的操作，即通过与计算机相联所完成的操作，比如计算机把正在运行的应用程序所计算出来的结果通过打印机打印到纸上。
 现在，脱机方式的操作更多的是指断网下进行的操作，联机方式是指在联网下进行的操作。

目前 Linux 有超过三百个的**系统调用接口(System Call Interface)**。下面列出了一些相对比较重要的操作系统接口或抽象，以及它们的大致功能：
- 进程（即程序运行过程）管理：复制创建进程 fork 、退出进程 exit 、执行进程 exec 等。
- 线程管理：线程（即程序的一个执行流）的创建、执行、调度切换等。
- 线程同步互斥的并发控制：互斥锁 mutex 、信号量 semaphore 、管程 monitor 、条件变量 condition variable 等。
- 进程间通信：管道 pipe 、信号 signal 、事件 event 等。
- 虚存管理：内存空间映射 mmap 、改变数据段地址空间大小 sbrk 、共享内存 shm 等。
- 文件 I/O 操作：对存储设备中的文件进行读 read 、写 write 、打开 open 、关闭 close 等操作。
- 外设 I/O 操作：外设包括键盘、显示器、串口、磁盘、时钟 … ，主要采用文件 I/O 操作接口。

抽象概念：
- 文件 (File) 是外设的一种抽象和虚拟化。特别对于存储外设而言，文件是持久存储的抽象。
- 地址空间 (Address Space) 是对内存的抽象和虚拟化。
- 进程 (Process) 是对计算机资源的抽象和虚拟化。而其中最核心的部分是对 CPU 的抽象与虚拟化

![400](assets/uTools_1691936024815.png)

![](assets/uTools_1691937556204.png)

- 物理资源：即计算机硬件资源，如CPU的寄存器、可访问的物理内存等。
- 虚拟资源：即操作系统提供的资源，如文件，网络端口号，网络地址，信号等。

在操作系统中，需要处理三类**异常控制流**：外设**中断** (Device Interrupt) 、**陷入** (Trap) 和**异常** (Exception，也称Fault Interrupt)。

进程上下文：

![500](assets/uTools_1692003020894.png)

文件：

![](assets/uTools_1692003763707.png)


# 第一章 应用程序与基本执行环境

![](assets/uTools_1692079341325.png)

![](assets/uTools_1698125802902.png)

指定交叉编译（target必须是编译器支持的，可以通过`rustup target add riscv64gc-unknown-none-elf`来安装，用`rustc --print target-list`查询已支持的）：
```config
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

riscv的拓展可以看成功能模块，多一个拓展就多一个功能。

去掉标准库之后，依然可以使用core库。core库不依赖于os，放哪里都能用。

通过编写链接配置文件，把代码段中的入口函数放在最低地址，即可让内存载入的时候起始点就是入口函数。前提是丢弃了没用的元数据，不然起始点可能是元数据而非可执行内容。

- **被调用者保存(Callee-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变；
- **调用者保存(Caller-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变

- sp会被被调用者自行分配、回收、管理，因此是被调用者保存寄存器。
- ra是在被调用者调用结束后进行跳转的目标，因此也是被调用者保存寄存器。
- fp用于被调用者结束后释放栈空间，因此也是被调用者保存寄存器。

>当前执行函数的栈帧的两个边界分别由栈指针 (Stack Pointer, sp(x2))寄存器和栈帧指针（frame pointer,  fp(s0)）寄存器来限定。

栈帧中有：
- `ra` 寄存器保存其返回之后的跳转地址，是一个被调用者保存寄存器；
- 父亲栈帧的结束地址 `fp` ，是一个被调用者保存寄存器；
- 其他被调用者保存寄存器 `s1` ~ `s11` ；
- 函数所使用到的局部变量。
![](assets/uTools_1698128364987.png)

函数调用：
```asmb
# 开场
# 为当前函数分配 64 字节的栈帧
addi        sp, sp, -64
# 将 ra 和 fp 压栈保存
sd  ra, 56(sp)
sd  s0, 48(sp)
# 更新 fp 为当前函数栈帧顶端地址
addi        s0, sp, 64

# 函数执行
# 中间如果再调用了其他函数会修改 ra

# 结尾
# 恢复 ra 和 fp
ld  ra, 56(sp)
ld  s0, 48(sp)
# 退栈
addi        sp, sp, 64
# 返回，使用 ret 指令或其他等价的实现方式
ret
```

可以通过使用space来让栈段直接申请一定的内存，这也可以很方便地检测是否栈溢出。
```asmb
 1# os/src/entry.asm
 2    .section .text.entry
 3    .globl _start
 4_start:
 5    la sp, boot_stack_top # 初始化sp
 6    call rust_main # 入口函数
 7
 8    .section .bss.stack # stack位于.bss.stack段
 9    .globl boot_stack_lower_bound
10boot_stack_lower_bound:
11    .space 4096 * 16 #栈空间
12    .globl boot_stack_top
13boot_stack_top:
```

>全局符号 `sbss` 和 `ebss` 来自于链接脚本，分别指向 `.bss` 段除 `.bss.stack` 以外的起始和终止地址，即指出需要被清零的 `.bss` 段的起始和终止地址，我们在使用这部分数据之前需要将它们初始化为零

通过函数名的方式来获得链接脚本中的符号位置：
```rust
extern "C" {
    fn sbss();
    fn ebss();
}
```


# 第二章 批处理系统

![](assets/uTools_1698134401117.png)

为了让应用程序获得操作系统的函数服务，采用传统的函数调用方式（即通常的 `call` 和 `ret` 指令或指令组合）将会直接绕过硬件的特权级保护检查。所以可以设计新的机器指令：执行环境调用（Execution Environment Call，简称 `ecall` ）和执行环境返回(Execution Environment Return，简称 `eret` )）：
- `ecall` ：具有用户态到内核态的执行环境切换能力的函数调用指令
- `eret` ：具有内核态到用户态的执行环境切换能力的函数返回指令

![400](assets/uTools_1698135926246.png)

>运行在 M 模式上的软件被称为 **监督模式执行环境** (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行

执行 `ecall` 这条指令时候则会随着 CPU 当前所处特权级而触发不同的异常，当 CPU 分别处于 M/S/U 三种特权级时执行 `ecall` 这条指令会触发三种异常。

M 模式软件 SEE 和 S 模式的内核之间的接口被称为 **监督模式二进制接口** (Supervisor Binary Interface, SBI)，而内核和 U 模式的应用程序之间的接口被称为 **应用程序二进制接口** (Application Binary Interface, ABI)，当然它有一个更加通俗的名字—— **系统调用** (syscall, System Call) 。

![](assets/uTools_1698138305266.png)

mret在M中用，sret在S中用。

S模式特权指令：

|指令|含义|
|---|---|
|sret|从 S 模式返回 U 模式：在 U 模式下执行会产生非法指令异常|
|wfi|处理器在空闲时进入低功耗状态等待中断：在 U 模式下执行会产生非法指令异常|
|sfence.vma|刷新 TLB 缓存：在 U 模式下执行会产生非法指令异常|
|访问 S 模式 CSR 的指令|通过访问 [sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 来改变系统状态：在 U 模式下执行会产生非法指令异常|

>CPU 对物理内存所做的缓存又分成 **数据缓存** (d-cache) 和 **指令缓存** (i-cache) 两部分，分别在 CPU 访存和取指的时候使用。在取指的时候，对于一个指令地址， CPU 会先去 i-cache 里面看一下它是否在某个已缓存的缓存行内，如果在的话它就会直接从高速缓存中拿到指令而不是通过总线访问内存。通常情况下， CPU 会认为程序的代码段不会发生变化，因此 i-cache 是一种只读缓存。但在这里，OS 将修改会被 CPU 取指的内存区域，这会使得 i-cache 中含有与内存中不一致的内容。因此， OS 在这里必须使用取指屏障指令 `fence.i` ，它的功能是保证 **在它之后的取指过程必须能够看到在它之前的所有对于取指内存区域的修改** ，这样才能保证 CPU 访问的应用代码是最新的而不是 i-cache 中过时的内容。

AEE（Application Execution Environment)

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 `stvec` 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，上面 提到过我们必须保存原控制流的寄存器状态，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而不是应用程序运行时用到的用户栈。

由于bss段不占用存储空间，只会在运行时占内存，因此很适合用来塞栈。所以可以用全局变量来表示栈。

>换栈是非常简单的，只需将 `sp` 寄存器的值修改为 `get_sp` 的返回值即可。

上下文：
```rust
4pub struct TrapContext {
5    pub x: [usize; 32],
6    pub sstatus: Sstatus,
7    pub sepc: usize,
8}
```

trap时会直接保存上下文到栈中，包括用户的状态和trap处理时的状态。

启动下一个应用程序时，相当于从trap中恢复，但要执行的是其他位置的应用程序，于是内核态给自己编造了一个context，然后走类似于trap恢复的路线。

`__restore` 函数的起始部分会完成 sp←a0，而a0是函数的第一个参数。传参时若传了内核栈的栈顶，就使得在 `__restore` 函数中 `sp` 仍然可以指向内核栈的栈顶。

# 第三章 多道程序和分时多任务

**多道程序** (Multiprogramming) 和 **分时多任务** (Time-Sharing Multitasking)

锯齿螈**多道程序**操作系统 - Multiprog OS（轮流执行）：
![](assets/uTools_1698223642896.png)

始初龙**协作式多道程序**操作系统 – CoopOS（主动放弃）：
![](assets/uTools_1698224271221.png)

腔骨龙**分时多任务**操作系统 – TimesharingOS（时钟中断）：
![](assets/uTools_1698224401893.png)

把应用程序的一次执行过程（也是一段控制流）称为一个 **任务** ，把应用执行过程中的一个时间片段上的执行片段或空闲片段称为 “ **计算任务片** ” 或“ **空闲任务片** ” 。当应用程序的所有任务片都完成后，应用程序的一次任务也就完成了。从一个程序的任务切换到另外一个程序的任务称为 **任务切换** 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。

所有任务的task-context放在os的数据段中，若一个task不在执行，则其上下文都被保存在对应位置。

`__switch` 函数和一个普通的函数之间的核心差别仅仅是它会 **换栈** （即把sp寄存器也作为状态的一部分进行更换或恢复）。

**主动** 调用 `sys_yield` 系统调用意味着应用主动交出 CPU 的使用权给其他应用。












