# 堆

## 建堆

指从无序数组建立堆。

两种方式：向下调整法和向上调整法。

- 无论是哪种调整法，其最坏情况就是调整直至碰顶或底。
- 都是从根节点开始往后遍历。

向下调整，越高的点调整的次数越多，同时越高的点总数越少，复杂度为O(n)。

向上调整，越低的点调整的次数越多，同时越低的点总数越多，复杂度为O(nlogn)。

因此，向下调整更优。

## 调整

一般每次只有一个结点破坏了堆，而只调整这个结点就能重塑堆，无论它在顶点还是叶子。复杂度为O(logn)。


# 快排

双指针。把标记拿走。 左边找小于标记的，右边找大于标记的，交换。不断移动直到双指针相撞，此时相撞的左边都是比标记小的，右边都是比标记大的。最后交换标记和相撞点即可。

>相撞有两种情形：
>先移动的指针到达其目标后等待，被后移动的撞上；
>后移动的指针交换完毕后，被下一轮先移动的撞上。
>这两种情形相撞的点都是满足先移动指针目标的点。
>
>因此：
>当选取最左边的元素为基准元素时，先移动的指针一定要是右边的指针（撞在小于目标处）。
>当选取最右边的元素为基准元素时，先移动的指针一定要是左边的指针（撞在大于目标处）。

# Floyd

结果为图上任意两个点之间的最短路径。

有两个矩阵，记录i->j最短距离的D矩阵和用于回溯的S矩阵，尺寸都为V\*V。

S矩阵存储最短路径i->j要经过的第一个节点。如1->5->6->8时，$S[1][8]=5$；则下次就会去找$S[5][8]$=6，然后$S[6][8]=8$；$8==8$，S矩阵值与终点相同，则是找完路径了。

初始化：遍历所有边(i,j，len)，$D[i][j]=len$ ；对任意的i，j，$S[i][j]=j$ 。（这里对S矩阵的初始化比较暴力，可能在非强连通图内出问题）

```python
#使用所有结点去松弛其他结点
for k in range(self.V):
	#遍历所有结点组合，让其被k结点松弛
	for i in range(self.V):
		for j in range(self.V):
			if self.D[i][j]>self.D[i][k]+self.D[k][j]:
				#松弛
				self.D[i][j]=self.D[i][k]+self.D[k][j]
				#取i->k路径的第一个途径结点作为i->j路径的第一个途径结点 
				self.S[i][j]=self.S[i][k] 
```


# 前缀和

```cpp
for(int i=1;i<len;i++){
	a[i]+=a[i-1];
}
```

## 快速求连续子数组的和

对整个数组求前缀和得到数组d，则第i项到第j项这一子数组（长度为j-i+1）的和为$d[j]-d[i-1]$。

## 区间加同一个数

需求：有一个全0的长度为n的数组a，每次令区间$[x_i,y_i]$都加上$k_i$，如此操作t次。

暴力加的时间复杂度最坏为$O(n*t)$。

可以让$a[x_i]+=k_i$，$a[y_i]-=k_i$；然后对a求前缀和.此时复杂度为$O(n+t)$。


# 并查集

对若干个元素进行同类合并，比如把有亲戚关系的人都合并到同一个集合里面，就能知道一群人可以分为几个家族。

每个元素都归属于一个元素，因此并查集是个森林；每个集合都是一个树；每个树结点只知道它的父结点；树根结点归属于它自己。

## 基本步骤

每一个集合都由其树根结点代表。

1. 初始化: 将每个元素都独立地作为一个集合。
2. 合并（union）: 若元素a和b有关系，则合并其所在集合。令b集合的树根归属于a集合的树根。
3. 查找（find）: 寻找一个元素的所在集合。一直向上查归属直到找到树根。

![300](assets/uTools_1689128872295.png)



## 优化

### 路径压缩

树的结构是可以修改的，只要树根正确即可。因此，在查找的时候，若a元素属于以r元素为树根的集合，则令a直接归属r。此时查询的平均时间复杂度为$O(logN)$。

![300](assets/uTools_1689129891643.png)

### 按秩合并

此处将秩（rank）定义为树的深度。合并集合a和集合b时，若a的深度小于等于b的深度，则让a挂到b的树根下。小于时，结果深度同b；等于时，结果深度为b深度加1。因此要维护好每个集合的秩，这样在合并时可以准确计算出新集合的秩而不需重新遍历树。此时查询的平均时间复杂度为$O(logN)$。

![300](assets/uTools_1689130262939.png)

![300](assets/uTools_1689130271556.png)

### 同时使用

两者也可同时使用，使得查询的平均时间复杂度降为$O(\alpha(N))$，为反阿克曼函数，可视为常数。

过程中可能由于路径压缩导致树的深度减少，此时也无需修改秩。可以理解为按秩合并尽可能优化了合并后的前几次查询。

### 示例

[LeetCode 200 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```cpp
class UnionFind {
public:
    UnionFind(vector<vector<char>>& grid) {
        count = 0;
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
	                //刚开始时每个1都独立成树，归属于自己
                    parent.push_back(i * n + j);
                    ++count;
                }
                else {
                    parent.push_back(-1);
                }
                //秩的绝对大小没有意义，可以直接设为0
                rank.push_back(0);
            }
        }
    }

    int find(int i) {
        if (parent[i] != i) {
	        //查找的同时进行路径压缩
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    void unite(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
	        //合并到大秩的树里面去
            if (rank[rootx] < rank[rooty]) {
                swap(rootx, rooty);
            }
            parent[rooty] = rootx;
            //等秩会导致深度多一个
            if (rank[rootx] == rank[rooty]) rank[rootx] += 1;
            --count;
        }
    }

    int getCount() const {
        return count;
    }

private:
    vector<int> parent;
    vector<int> rank;
    int count;
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        UnionFind uf(grid);
        int num_islands = 0;
        //这里不需要上下左右都看着unite。由于是从左上遍历到右下，因此只要合并左边和上边就行了。
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') uf.unite(r * nc + c, (r-1) * nc + c);
                    if (r + 1 < nr && grid[r+1][c] == '1') uf.unite(r * nc + c, (r+1) * nc + c);
                    if (c - 1 >= 0 && grid[r][c-1] == '1') uf.unite(r * nc + c, r * nc + c - 1);
                    if (c + 1 < nc && grid[r][c+1] == '1') uf.unite(r * nc + c, r * nc + c + 1);
                }
            }
        }

        return uf.getCount();
    }
};

作者：LeetCode
链接：https://leetcode.cn/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 杂记

追求输出效率时不要用endl。


































