
[GitHub - youngyangyang04/leetcode-master: ã€Šä»£ç éšæƒ³å½•ã€‹LeetCode åˆ·é¢˜æ”»ç•¥ï¼š200é“ç»å…¸é¢˜ç›®åˆ·é¢˜é¡ºåºï¼Œå…±60wå­—çš„è¯¦ç»†å›¾è§£ï¼Œè§†é¢‘éš¾ç‚¹å‰–æï¼Œ50ä½™å¼ æ€ç»´å¯¼å›¾ï¼Œæ”¯æŒC++ï¼ŒJavaï¼ŒPythonï¼ŒGoï¼ŒJavaScriptç­‰å¤šè¯­è¨€ç‰ˆæœ¬ï¼Œä»æ­¤ç®—æ³•å­¦ä¹ ä¸å†è¿·èŒ«ï¼ğŸ”¥ğŸ”¥ æ¥çœ‹çœ‹ï¼Œä½ ä¼šå‘ç°ç›¸è§æ¨æ™šï¼ğŸš€](https://github.com/youngyangyang04/leetcode-master)

# äºŒåˆ†æ³•

å½“æ•´æ•°a<bæ—¶ï¼Œ$a + (b - a) / 2$ç­‰ä»·äº$(a + b) / 2$ã€‚

```rust
pub fn minimize_array_value(nums: Vec<i32>) -> i32 {
	let mut left = 0;
	let mut right = nums.iter().max().unwrap().clone();
	let mut mid = -1;
	while(left<right){
		mid = left+(right-left)/2;
		//println!("{} {} {}",left,right,mid);
		if Self::check(&nums,mid){
			right = mid; //æ²¡æœ‰-1
		}else{
			left = mid+1;
		}
	}
	//æ­¤æ—¶left=rightä¸”æ»¡è¶³rightä¾§çš„è¦æ±‚
	//println!("end: {} {} {}",left,right,mid);
	left
}
```


# å¿«é€Ÿå¹‚

æ—¶é—´å¤æ‚åº¦$O(logN)$ã€‚å¯ä»¥å¾ˆå®¹æ˜“åœ°æ”¹æˆå¿«é€ŸåŠ ç®—æ³•ã€‚

```cpp
double quickMul(double x, int N) {
	if (N == 0) {
		return 1.0;
	}
	double y = quickMul(x, N / 2);
	//å¥‡æ•°æ—¶quickMul(x, N / 2)å°‘ç®—äº†ä¸ªxï¼Œè¦è¡¥ä¸Š
	return N % 2 == 0 ? y * y : y * y * x; 
}

double myPow(double x, int n) {
	return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
}
```

# å †

## å»ºå †

æŒ‡ä»æ— åºæ•°ç»„å»ºç«‹å †ã€‚

ä¸¤ç§æ–¹å¼ï¼šå‘ä¸‹è°ƒæ•´æ³•å’Œå‘ä¸Šè°ƒæ•´æ³•ã€‚

- æ— è®ºæ˜¯å“ªç§è°ƒæ•´æ³•ï¼Œå…¶æœ€åæƒ…å†µå°±æ˜¯è°ƒæ•´ç›´è‡³ç¢°é¡¶æˆ–åº•ã€‚
- éƒ½æ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹å¾€åéå†ã€‚

å‘ä¸‹è°ƒæ•´ï¼Œè¶Šé«˜çš„ç‚¹è°ƒæ•´çš„æ¬¡æ•°è¶Šå¤šï¼ŒåŒæ—¶è¶Šé«˜çš„ç‚¹æ€»æ•°è¶Šå°‘ï¼Œå¤æ‚åº¦ä¸ºO(n)ã€‚

å‘ä¸Šè°ƒæ•´ï¼Œè¶Šä½çš„ç‚¹è°ƒæ•´çš„æ¬¡æ•°è¶Šå¤šï¼ŒåŒæ—¶è¶Šä½çš„ç‚¹æ€»æ•°è¶Šå¤šï¼Œå¤æ‚åº¦ä¸ºO(nlogn)ã€‚

å› æ­¤ï¼Œå‘ä¸‹è°ƒæ•´æ›´ä¼˜ã€‚

## è°ƒæ•´

ä¸€èˆ¬æ¯æ¬¡åªæœ‰ä¸€ä¸ªç»“ç‚¹ç ´åäº†å †ï¼Œè€Œåªè°ƒæ•´è¿™ä¸ªç»“ç‚¹å°±èƒ½é‡å¡‘å †ï¼Œæ— è®ºå®ƒåœ¨é¡¶ç‚¹è¿˜æ˜¯å¶å­ã€‚å¤æ‚åº¦ä¸ºO(logn)ã€‚

## ä¼˜å…ˆçº§é˜Ÿåˆ—

[239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼ é¢˜è§£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)

æ˜¯ç”¨å †å®ç°çš„ï¼Œå¯ä»¥æ’å…¥æ–°å…ƒç´ ï¼Œæˆ–è®¿é—®/å¼¹å‡ºå †é¡¶å…ƒç´ ã€‚

# å¿«æ’

åŒæŒ‡é’ˆã€‚æŠŠæ ‡è®°æ‹¿èµ°ã€‚ å·¦è¾¹æ‰¾å°äºæ ‡è®°çš„ï¼Œå³è¾¹æ‰¾å¤§äºæ ‡è®°çš„ï¼Œäº¤æ¢ã€‚ä¸æ–­ç§»åŠ¨ç›´åˆ°åŒæŒ‡é’ˆç›¸æ’ï¼Œæ­¤æ—¶ç›¸æ’çš„å·¦è¾¹éƒ½æ˜¯æ¯”æ ‡è®°å°çš„ï¼Œå³è¾¹éƒ½æ˜¯æ¯”æ ‡è®°å¤§çš„ã€‚æœ€åäº¤æ¢æ ‡è®°å’Œç›¸æ’ç‚¹å³å¯ã€‚

>ç›¸æ’æœ‰ä¸¤ç§æƒ…å½¢ï¼š
>å…ˆç§»åŠ¨çš„æŒ‡é’ˆåˆ°è¾¾å…¶ç›®æ ‡åç­‰å¾…ï¼Œè¢«åç§»åŠ¨çš„æ’ä¸Šï¼›
>åç§»åŠ¨çš„æŒ‡é’ˆäº¤æ¢å®Œæ¯•åï¼Œè¢«ä¸‹ä¸€è½®å…ˆç§»åŠ¨çš„æ’ä¸Šã€‚
>è¿™ä¸¤ç§æƒ…å½¢ç›¸æ’çš„ç‚¹éƒ½æ˜¯æ»¡è¶³å…ˆç§»åŠ¨æŒ‡é’ˆç›®æ ‡çš„ç‚¹ã€‚
>
>å› æ­¤ï¼š
>å½“é€‰å–æœ€å·¦è¾¹çš„å…ƒç´ ä¸ºåŸºå‡†å…ƒç´ æ—¶ï¼Œå…ˆç§»åŠ¨çš„æŒ‡é’ˆä¸€å®šè¦æ˜¯å³è¾¹çš„æŒ‡é’ˆï¼ˆæ’åœ¨å°äºç›®æ ‡å¤„ï¼‰ã€‚
>å½“é€‰å–æœ€å³è¾¹çš„å…ƒç´ ä¸ºåŸºå‡†å…ƒç´ æ—¶ï¼Œå…ˆç§»åŠ¨çš„æŒ‡é’ˆä¸€å®šè¦æ˜¯å·¦è¾¹çš„æŒ‡é’ˆï¼ˆæ’åœ¨å¤§äºç›®æ ‡å¤„ï¼‰ã€‚

# äºŒå‰æ ‘

## æœ€è¿‘å…¬å…±ç¥–å…ˆ

[236.Â äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

pã€qçš„æœ€è¿‘å…¬å…±ç¥–å…ˆå¿…ç„¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„å…¶ä¸­ä¸€ä¸ªï¼Œä¸”å…¶ä»–ç»“ç‚¹éƒ½ä¸æ»¡è¶³ï¼š
- å·¦å­æ ‘é‡Œé¢æœ‰å…¶ä¸€ï¼Œå³å­æ ‘é‡Œé¢æœ‰å¦ä¸€ä¸ª
- è‡ªå·±å°±æ˜¯å…¶ä¸€ï¼ŒæŸä¸€ä¸ªå­æ ‘é‡Œé¢æœ‰å¦ä¸€ä¸ª

ä½¿ç”¨ååºéå†ï¼Œå°†æ˜¯å¦å­˜åœ¨çš„ä¿¡æ¯å‘ä¸Šä¼ é€’ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ç‚¹æ»¡è¶³æ­¤æ¡ä»¶ï¼Œå¹¶ä¸”ä»…èƒ½æ‰¾åˆ°ä¸€ç‚¹ã€‚

åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œè‹¥æ±‚æ ‘æ ¹åˆ°pã€qçš„è·¯å¾„æ¯”è¾ƒç®€å•ï¼ˆå¦‚äºŒå‰æœç´¢æ ‘ï¼‰ï¼Œåˆ™å¯ä»¥ç›´æ¥æ¯”å¯¹è·¯å¾„çš„æœ€ç»ˆé‡åˆç‚¹ã€‚

## æ„é€ äºŒå‰æ ‘

[â€œçœ‹æˆ‘å°±å¤Ÿäº†â€ä¸‰ç§éå†æ–¹å¼æ„é€ äºŒå‰æ ‘çš„é€šè§£](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/290943/kan-wo-jiu-gou-liao-san-chong-bian-li-fang-shi-gou/)

ç®—æ³•æ¨¡å¼ï¼šå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå…¶åŠŸèƒ½ä¸ºï¼š**ç”±order1çš„è¿ç»­çš„æŸä¸€æ®µå’Œorder2çš„ç­‰é•¿çš„è¿ç»­çš„æŸä¸€æ®µæ¥æ„é€ ä¸€æ£µæ ‘**ã€‚æ„é€ æ—¶ï¼Œå…ˆå¯»æ‰¾åˆ’åˆ†ä½ç½®ï¼ˆåœ¨ä¸­åºä¸­å¯»æ‰¾å‰åºæˆ–è€…ååºçš„æ•°å­—å³ä¸º**å½“å‰çš„æ ‘æ ¹**ï¼›åœ¨ååºä¸­å¯»æ‰¾å‰åºçš„æ•°å­—å³ä¸º**å·¦å­æ ‘çš„æ ‘æ ¹**ï¼‰ï¼Œç„¶åæ ¹æ®**orderçš„æ€§è´¨**ä¸**å­æ ‘çš„å°ºå¯¸**æ¥åˆ’åˆ†å·¦å³å­æ ‘å¯¹åº”çš„orderèŒƒå›´ï¼Œå¹¶è¿›è¡Œé€’å½’æ„å»ºã€‚

å¯»æ‰¾åˆ’åˆ†ä½ç½®æ—¶å¯ä»¥ç”¨å“ˆå¸Œè¡¨åŠ é€Ÿã€‚

### å‰åº&ä¸­åº

[105.Â ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

æ ¹ç»“ç‚¹ä¸º`pre[pre_start]`ï¼Œæ‰¾åˆ°å…¶åœ¨inä¸­çš„ä½ç½®ï¼Œå°±èƒ½å°†inåˆ’åˆ†ä¸ºå·¦å³å­æ ‘ï¼Œç„¶åæ ¹æ®åˆ’åˆ†çš„å°ºå¯¸å°†preä¹Ÿåˆ’åˆ†ä¸ºå·¦å³å­æ ‘ã€‚

å·¦å³å­æ ‘èŒƒå›´ï¼š
- in:
	- å·¦å­æ ‘ï¼š`[inorder_start,index-1]`
	- å³å­æ ‘ï¼š`[index+1, inorder_end]`
- pre:
	- å·¦å­æ ‘ï¼š`[pre_start+1, pre_start+1 + (index-1 - inorder_start)]` 
	- å³å­æ ‘ï¼š`[(pre_start+1 + (index-1 - inorder_start)) + 1, pre_end]`

åœ¨å‰åºéå†ä¸­ï¼Œå·¦å­æ ‘èµ·å§‹ä½ç½®ä¸ºpre_start+1,å·¦å­æ ‘ç»“ç‚¹ä¸€å…±æœ‰`index-1 - inorder_start`ä¸ªã€‚å³å­æ ‘èµ·å§‹ä½ç½®ä¸ºå·¦å­æ ‘ç»ˆæ­¢ä½ç½®+1ï¼Œç›´åˆ°æœ€åã€‚

```cpp
unordered_map<int, int> index;

TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
	if (preorder_left > preorder_right) {
		return nullptr;
	}
	
	// å‰åºéå†ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
	int preorder_root = preorder_left;
	// åœ¨ä¸­åºéå†ä¸­å®šä½æ ¹èŠ‚ç‚¹
	int inorder_root = index[preorder[preorder_root]];
	
	// å…ˆæŠŠæ ¹èŠ‚ç‚¹å»ºç«‹å‡ºæ¥
	TreeNode* root = new TreeNode(preorder[preorder_root]);
	// å¾—åˆ°å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®
	int size_left_subtree = inorder_root - inorder_left;
	// é€’å½’åœ°æ„é€ å·¦å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
	// å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1 å¼€å§‹çš„ size_left_subtreeã€ä¸ªå…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ å¼€å§‹åˆ° æ ¹èŠ‚ç‚¹å®šä½-1ã€çš„å…ƒç´ 
	root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
	// é€’å½’åœ°æ„é€ å³å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
	// å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1+å·¦å­æ ‘èŠ‚ç‚¹æ•°ç›® å¼€å§‹åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» æ ¹èŠ‚ç‚¹å®šä½+1 åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ 
	root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
	return root;
}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
	int n = preorder.size();
	// æ„é€ å“ˆå¸Œæ˜ å°„ï¼Œå¸®åŠ©æˆ‘ä»¬å¿«é€Ÿå®šä½æ ¹èŠ‚ç‚¹
	for (int i = 0; i < n; ++i) {
		index[inorder[i]] = i;
	}
	return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
}
```

### ä¸­åº&ååº

æ ¹ç»“ç‚¹ä¸º`post[post_end]`ï¼Œæ‰¾åˆ°å…¶åœ¨inä¸­çš„ä½ç½®ï¼Œå°±èƒ½å°†inåˆ’åˆ†ä¸ºå·¦å³å­æ ‘ï¼Œç„¶åæ ¹æ®åˆ’åˆ†çš„å°ºå¯¸å°†postä¹Ÿåˆ’åˆ†ä¸ºå·¦å³å­æ ‘ã€‚

å·¦å³å­æ ‘èŒƒå›´ï¼š
- in:
	- å·¦å­æ ‘ï¼š`[inorder_start,index-1]`
	- å³å­æ ‘ï¼š`[index+1, inorder_end]`
- post:
	- å·¦å­æ ‘ï¼š`[post_start, post_start + (index-1 - inorder_start)]` 
	- å³å­æ ‘ï¼š`[(pre_start + (index-1 - inorder_start)) + 1, post_end - 1]`

åœ¨ååºéå†ä¸­ï¼Œå·¦å­æ ‘èµ·å§‹ä½ç½®ä¸º`post_start`ï¼Œå·¦å­æ ‘ç»“ç‚¹ä¸€å…±æœ‰`index-1 - inorder_start`ä¸ªã€‚å³å­æ ‘èµ·å§‹ä½ç½®ä¸ºå·¦å­æ ‘ç»ˆæ­¢ä½ç½®+1ï¼Œç›´åˆ°æœ€å-1ï¼ˆå› ä¸ºæœ€åæ˜¯å½“å‰çš„æ ¹ç»“ç‚¹ï¼‰ã€‚å³å­æ ‘ä¹Ÿå¯ä»¥æ¢ä¸€ç§å½¢å¼è¡¨è¾¾ï¼šå³å­æ ‘çš„ç»ˆæ­¢ä½ç½®ä¸º`post_end - 1`,å³å­æ ‘ç»“ç‚¹ä¸€å…±æœ‰`inorder_end - (index+1)`ä¸ªï¼Œå› æ­¤è¡¨ç¤ºä¸º`[post_end - 1 - (inorder_end - (index+1)), post_end - 1]`ã€‚

æœ‰ä¸€ä¸ªå·§åˆï¼Œå¦‚æœå…ˆé€ å³å­æ ‘ã€å†é€ å·¦å­æ ‘çš„è¯ï¼Œå°±ç›¸å½“äºä»åå¾€å‰ä¸€ä¸ªä¸€ä¸ªæ¶ˆè´¹ååºéå†ï¼Œå› æ­¤å¦‚æœæŠŠååºéå†çš„ä¸‹æ ‡æå–ä¸ºå…¨å±€å˜é‡ï¼Œä¸”æ¯æ„é€ ä¸€ä¸ªèŠ‚ç‚¹å°±è¿›è¡Œä¸€æ¬¡å·¦ç§»çš„è¯ï¼Œå°±ä¸éœ€è¦è®°å®ƒäº†ã€‚

```cpp
int post_idx;
unordered_map<int, int> idx_map;

TreeNode* helper(int in_left, int in_right, vector<int>& inorder, vector<int>& postorder){
	// å¦‚æœè¿™é‡Œæ²¡æœ‰èŠ‚ç‚¹æ„é€ äºŒå‰æ ‘äº†ï¼Œå°±ç»“æŸ
	if (in_left > in_right) {
		return nullptr;
	}

	// é€‰æ‹© post_idx ä½ç½®çš„å…ƒç´ ä½œä¸ºå½“å‰å­æ ‘æ ¹èŠ‚ç‚¹
	int root_val = postorder[post_idx];
	TreeNode* root = new TreeNode(root_val);

	// æ ¹æ® root æ‰€åœ¨ä½ç½®åˆ†æˆå·¦å³ä¸¤æ£µå­æ ‘
	int index = idx_map[root_val];

	// ä¸‹æ ‡å‡ä¸€
	post_idx--;
	// æ„é€ å³å­æ ‘
	root->right = helper(index + 1, in_right, inorder, postorder);
	// æ„é€ å·¦å­æ ‘
	root->left = helper(in_left, index - 1, inorder, postorder);
	return root;
}

TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
	// ä»ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹
	post_idx = (int)postorder.size() - 1;

	// å»ºç«‹ï¼ˆå…ƒç´ ï¼Œä¸‹æ ‡ï¼‰é”®å€¼å¯¹çš„å“ˆå¸Œè¡¨
	int idx = 0;
	for (auto& val : inorder) {
		idx_map[val] = idx++;
	}
	return helper(0, (int)inorder.size() - 1, inorder, postorder);
}
```
### å‰åº&ååº

[889.Â æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

æ ¹èŠ‚ç‚¹ä¸º`pre[pre_start]`,åŒæ—¶ä¹Ÿæ˜¯`post[post_end]`ã€‚

å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ä¸º`pre[pre_start+1]`ï¼Œåœ¨postä¸­å¯»æ‰¾å®ƒï¼Œå³å¯å°†poståˆ’åˆ†ä¸ºå·¦å³å­æ ‘ï¼Œç„¶åæ ¹æ®åˆ’åˆ†çš„å°ºå¯¸æŠŠpreä¹Ÿåˆ’åˆ†ä¸ºå·¦å³å­æ ‘ã€‚

å·¦å³å­æ ‘èŒƒå›´ï¼š
- post
	- å·¦å­æ ‘ï¼š`[post_start,index]`
	- å³å­æ ‘ï¼š`[index+1, post_end-1]` 
- pre
	- å·¦å­æ ‘ï¼š`[pre_start+1, pre_start+1 + (index - post_start)]`
	- å³å­æ ‘ï¼š`[(pre_start+1 + (index - post_start)) + 1, pre_end]`

åœ¨å‰åºéå†ä¸­ï¼Œå·¦å­æ ‘èµ·å§‹ä½ç½®ä¸º`pre_start+1`,å·¦å­æ ‘çš„ç»“ç‚¹ä¸ªæ•°ä¸€å…±æœ‰`index - post_start`ä¸ªï¼Œåœ¨èµ·ç‚¹åè¿ç»­æ’å¸ƒï¼›å³å­æ ‘èµ·å§‹ä½ç½®ä¸ºå·¦å­æ ‘ç»ˆæ­¢ä½ç½®+1ï¼Œç›´åˆ°æœ€åã€‚


```cpp
TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
	return build(preorder,postorder,0,preorder.size()-1,0,postorder.size()-1);
}

TreeNode* build(vector<int> &pre, vector<int> &post,
	int preStart,int preEnd,int postStart,int postEnd){
	if(preStart > preEnd || postStart>postEnd){
		return nullptr;
	}

	TreeNode* root = new TreeNode(pre[preStart]);

	//é˜²æ­¢pre[preStart+1]è¶Šç•Œ
	if(preStart == preEnd){
		return root;
	}

	//å¯»æ‰¾postorderä¸­çš„å·¦æ ¹ç»“ç‚¹pre[preStart+1]çš„ä½ç½®
	//å¯ä»¥ç”¨unordered_mapåŠ é€Ÿ
	int index = 0;
	while(post[index]!=pre[preStart+1]){
		index++;
	}

	int leftPreEnd = preStart+1+index-postStart;
	root->left = build(pre,post,
		preStart+1,leftPreEnd,
		postStart,index);
	root->right = build(pre,post,
		leftPreEnd+1,preEnd,
		index+1,postEnd-1);

	return root;
}
```

å‰åºå’Œååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ï¼ŒåŸå› æ˜¯å½“ä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­çš„æ—¶å€™æ— æ³•ç¡®å®šæ˜¯å·¦å­©å­è¿˜æ˜¯å³å­©å­ã€‚

ä½†ä¾ç„¶èƒ½å”¯ä¸€ç¡®å®šå³è§†å›¾ï¼ˆæ¯ä¸€å±‚çš„æœ€å³ä¾§ç»“ç‚¹ï¼‰ï¼Œåªè¦é»˜è®¤ä¸ºå·¦å­©å­å³å¯ï¼š

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* buildTree(vector<int>& preorder, vector<int>& postorder) {
    if (preorder.empty() || postorder.empty()) {
        return nullptr;
    }
    //è‹¥ä¸çŸ¥é“æ”¾åœ¨å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼Œåˆ™é»˜è®¤å·¦è¾¹ 
    int rootVal = preorder[0];
    TreeNode* root = new TreeNode(rootVal);
    if (preorder.size() == 1) {
        return root;
    }
    int leftSize = 0;
    while (postorder[leftSize] != preorder[1]) {
        leftSize++;
    }
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + leftSize + 2);
    vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftSize + 1);
    vector<int> rightPreorder(preorder.begin() + leftSize + 2, preorder.end());
    vector<int> rightPostorder(postorder.begin() + leftSize + 1, postorder.end() - 1);
    root->left = buildTree(leftPreorder, leftPostorder);
    root->right = buildTree(rightPreorder, rightPostorder);
    return root;
}

vector<int> rightSideView(TreeNode* root) {
    vector<int> result;
    if (root == nullptr) {
        return result;
    }
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            cout<<node->val<<" ";
            q.pop();
            if (i == size - 1) {
                result.push_back(node->val);
               	cout<<endl;
            }
            if (node->left != nullptr) {
                q.push(node->left);
            }
            if (node->right != nullptr) {
                q.push(node->right);
            }
        }
    }
    return result;
}

int main() {
    //vector<int> preorder = {1, 2, 4, 5, 3, 6, 7};
    //vector<int> postorder = {4, 5, 2, 6, 7, 3, 1};
    
    //vector<int> preorder = {1, 2, 4, 7, 5, 3, 6};
    //vector<int> postorder = {7, 4, 5, 2, 6, 3, 1};
    
    vector<int> preorder = {1, 2, 4, 7, 3, 6};
    vector<int> postorder = {7, 4, 2, 6, 3, 1};
    
    TreeNode* root = buildTree(preorder, postorder);
    
    // å¯¹æ„å»ºçš„äºŒå‰æ ‘è¿›è¡Œæ“ä½œ
    vector<int> rightView = rightSideView(root);
    cout << "Right View: ";
    for (int num : rightView) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

# èƒŒåŒ…é—®é¢˜

## 01èƒŒåŒ…

å¯ä»¥åŒ–ä¸º01èƒŒåŒ…é—®é¢˜çš„æ‰€æœ‰é—®é¢˜çš„æŠ½è±¡è¡¨è¿°ï¼šå­˜åœ¨ä¸€ç³»åˆ—å…ƒç´ $\omega_i$ï¼Œè¦ä¹ˆå½’å±äºAï¼Œè¦ä¹ˆå½’å±äºBï¼Œæ²¡æœ‰å…¶ä»–é€‰é¡¹ï¼›æ¯ä¸ªå…ƒç´ éƒ½æœ‰æƒå€¼$v_i$ï¼Œéå†ä¸­ä¹Ÿå­˜åœ¨é™åˆ¶æ¡ä»¶$p_j$ï¼›é€šè¿‡éå†å…ƒç´ çš„å½’å±ï¼Œè¿‡ç¨‹ä¸­æ»¡è¶³é™åˆ¶æ¡ä»¶ï¼Œè§‚å¯Ÿæƒå€¼å˜åŒ–ï¼Œå¾—å‡ºç­”æ¡ˆã€‚

ç»å…¸01èƒŒåŒ…ä¸­ï¼Œå…ƒç´ å°±æ˜¯å„ä¸ªç‰©ä½“ï¼ŒAæ˜¯æ”¾å…¥èƒŒåŒ…ï¼ŒBæ˜¯èˆå¼ƒï¼Œæƒå€¼æ˜¯ä»·å€¼ï¼Œé™åˆ¶æ¡ä»¶æ˜¯Aä¸­æ€»ä½“ç§¯ä¸èƒ½è¶Šç•Œï¼ˆç•Œé™ç”±éå†è¿‡ç¨‹å†³å®šï¼Œæœ€å¤§ä¸ºAçš„å®¹é‡ï¼‰ï¼Œéå†è¿‡ç¨‹ä¸­æƒå€¼å–å¤§ï¼Œç­”æ¡ˆåœ¨ä½“ç§¯æœ€å¤§ã€éå†å®Œæ‰€æœ‰å…ƒç´ å¤„ã€‚

æ³¨æ„ï¼Œä»¥å€¼çš„å½¢å¼æˆä¸ºæ•°ç»„é•¿åº¦çš„â€œä½“ç§¯â€æŒ‡çš„æ˜¯èƒŒåŒ…çš„å®¹é‡è€Œä¸æ˜¯è£…çš„ç‰©ä½“çš„ä½“ç§¯ã€‚

$f [i] [j] = max (f [i - 1] [j], f [i - 1] [j - w [i]] + v [j])$

å³æŒ‰é¡ºåºè€ƒè™‘ç‰©å“iï¼Œä»å°åˆ°å¤§è€ƒè™‘èƒŒåŒ…å¤§å°ï¼Œå¯¹æ¯ä¸ªèƒŒåŒ…å¤§å°åªèƒ½ï¼š
- ä¸è£…iï¼Œç­‰ä»·äºè€ƒè™‘i-1æ—¶çš„åŒå¤§å°èƒŒåŒ…çš„æœ€ä¼˜è§£ã€‚
- è£…iï¼Œåˆ™è£…ä¹‹å‰å¯¹åº”çš„çŠ¶æ€æ˜¯è€ƒè™‘i-1æ—¶å°äº†$w[i]$çš„èƒŒåŒ…çš„æœ€ä¼˜è§£ã€‚

dpæ•°ç»„çš„å¤§å°ä¸º$(item\_num+1)*(max\_size+1)$ï¼Œç‰©å“ä¸º0å¤„è¡¨ç¤ºä¸è€ƒè™‘ä»»ä½•ç‰©å“æ—¶çš„çŠ¶æ€ã€‚

dpæ•°ç»„å…ƒç´ çš„ç±»å‹ä¸æ„ä¹‰å¯ä»¥éšæ„å˜åŒ–ã€‚ä¸éœ€è¦è€ƒè™‘æƒé‡å¤§å°ã€åªè€ƒè™‘å¯èƒ½æ€§çš„æ—¶å€™ï¼Œdpæ•°ç»„çš„ç±»å‹ä¸ºboolã€‚è®¡ç®—å¯èƒ½æ€§æ•°é‡çš„æ—¶å€™ï¼Œå°†ä¸¤ä¸ªæ¥æºçš„å¯èƒ½æ€§æ•°é‡ç›¸åŠ å³å¯ã€‚

è‹¥æƒ³è¦ä½¿ç”¨æ»šåŠ¨æ•°ç»„çš„è¯ï¼Œæ³¨æ„å¾ˆå¤šæ—¶å€™éœ€è¦ä»å¤§åˆ°å°éå†ï¼Œè¿™æ ·çš„è¯å°±ä¸ä¼šè®¿é—®åˆ°å½“å‰ç‰©å“çš„å˜åŒ–ã€‚

**æ»šåŠ¨æ•°ç»„ä¼˜åŒ–åï¼Œæ•°ç»„è€ƒå‰çš„ä¸€æ®µä¸ä¼šæ”¹å˜ï¼Œå¯ä»¥ç›´æ¥è·³è¿‡ä¸éå†ã€‚**

### æ°å¥½è£…æ»¡çš„01èƒŒåŒ…

è€ƒè™‘ç¬¬iä¸ªç‰©å“æ—¶ï¼Œå®ƒçš„æœ€ä¼˜è§£åªèƒ½ï¼š
- æ¥è‡ªäºi-1ä¸­å®¹é‡ç›¸åŒçš„èƒŒåŒ…ã€‚
- æ¥è‡ªäºi-1ä¸­å®¹é‡ä¸º0~$max- w [i]$çš„èƒŒåŒ…ã€‚

è€Œè‹¥æœ‰è§£ï¼Œåˆ™æœ€åä¸€ä¸ªç‰©å“ï¼ˆiï¼‰çš„æœ€å¤§å®¹é‡èƒŒåŒ…å¿…ç„¶æ˜¯åˆšå¥½è£…æ»¡çš„ï¼Œäºæ˜¯ï¼š
- å¦‚æœå®ƒæ¥è‡ªäºå‰è€…æƒ…å½¢ï¼Œç”±äºå®¹é‡å’Œå·²è£…ç‰©å“éƒ½ä¸å˜ï¼Œå› æ­¤ä¹Ÿå¿…ç„¶æ˜¯åˆšå¥½è£…æ»¡çš„ã€‚
- å¦‚æœå®ƒæ¥è‡ªäºåè€…æƒ…å½¢ï¼Œåˆ™æ”¾å…¥ç‰©å“iä¹‹å‰çš„èƒŒåŒ…ä¹Ÿå¿…ç„¶æ˜¯åˆšå¥½è£…æ»¡çš„ã€‚

å¾—å‡ºç»“è®ºï¼Œ**æœ€ç»ˆè§£ä¸€è·¯ä¸Šçš„æ¥æºå…¨æ˜¯æ°å¥½è£…æ»¡çš„èƒŒåŒ…**ï¼Œå› æ­¤ä¸è£…æ»¡çš„èƒŒåŒ…çš„æƒ…å½¢å¯ä»¥å…¨éƒ¨æ‰”æ‰ã€‚åˆå§‹æ—¶åªæœ‰èƒŒåŒ…å®¹é‡ä¸º0æ‰æ»¡è¶³æ­¤è¦æ±‚ã€‚

[494.Â ç›®æ ‡å’Œ](https://leetcode.cn/problems/target-sum/)

>å¯ä»¥è½¬åŒ–ä¸ºæ°å¥½è£…æ»¡çš„01èƒŒåŒ…çš„é—®é¢˜ï¼šç»™å‡ºä¸€äº›æ•°$x_i$å’Œä¸€ä¸ªå¸¸æ•°hï¼Œæ±‚xçš„æŸä¸ªç»„åˆï¼Œä½¿å¾—$\sum x_i=h$ï¼Œå¹¶ç»™å‡ºæ»¡è¶³æ­¤çŠ¶æ€ä¸‹$f(x_i,...,x_j)$ çš„æœ€å¤§å€¼ã€‚
>å°†$x_i$å…¨éƒ¨åŠ ä¸Šä¸€ä¸ªå¤§å¸¸æ•°åï¼Œéƒ½è½¬åŒ–ä¸ºæ­£æ•°ï¼›ç‰©å“içš„ä½“ç§¯å°±æ˜¯æ•°çš„å¤§å°$x_i$ï¼Œè€Œå…¶ä»·å€¼ç”±å‡½æ•°få†³å®šã€‚

æœ‰çš„é—®é¢˜å¹¶ä¸è¦æ±‚æœ€åè£…æ»¡ï¼Œè€Œæ˜¯çœ‹æ‰€æœ‰ç‰©å“èƒ½å¦å‡‘å‡ºå“ªäº›ä½“ç§¯ï¼Œè¿™å°±éœ€è¦ç»“æŸåéå†dpæ•°ç»„ä¸­æœ€åä¸€ä¸ªç‰©å“çš„æ‰€æœ‰å®¹é‡æƒ…å†µï¼š[1049.Â æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II](https://leetcode.cn/problems/last-stone-weight-ii/)

ç”±æ­¤è¿˜èƒ½çœ‹å‡ºèƒ½è½¬åŒ–ä¸º01èƒŒåŒ…çš„é—®é¢˜ä¸­å¯èƒ½å…±æœ‰çš„æ€§è´¨ï¼šæ¯ä¸ªç‰©å“è¦ä¹ˆå±äºAï¼Œè¦ä¹ˆå±äºBï¼Œä½†æ‰€æœ‰ç‰©å“çš„æ€»å€¼sumåœ¨ä¸€å¼€å§‹å°±å¯ä»¥æ±‚å‡ºæ¥ï¼Œå› æ­¤$A=sum-B$ã€‚é‚£ä¹ˆå°±å¯ä»¥æ¨å‡º$ans=A-B=sum-2*B$ï¼Œä»¥ansçš„èŒƒå›´æ¥ç¡®å®šBçš„èŒƒå›´ï¼Œä»è€Œè½¬åŒ–ä¸ºâ€œæŠŠå¤šå°‘ç‰©å“å½’ç±»åˆ°Bâ€çš„01èƒŒåŒ…é—®é¢˜ã€‚

## å®Œå…¨èƒŒåŒ…

æœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªèƒ½èƒŒé‡é‡ä¸ºWçš„èƒŒåŒ…ï¼Œç¬¬iä»¶ç‰©å“çš„é‡é‡ä¸º$weight[i]$,ä»·å€¼ä¸º$value[i]$ã€‚**æ¯ä»¶ç‰©å“æœ‰æ— é™ä¸ª(ä¹Ÿå°±æ˜¯å¯ä»¥æ”¾å…¥èƒŒåŒ…å¤šæ¬¡ï¼‰**ï¼Œæ±‚æ€æ ·å¯ä»¥ä½¿èƒŒåŒ…ç‰©å“ä»·å€¼æ€»é‡æœ€å¤§ã€‚

dpæ•°ç»„åªæœ‰ä¸€ç»´ï¼Œå¤§å°ä¸º$max\_size+1$ã€‚

æ±‚ç»„åˆçš„æ€»æ•°æ—¶ï¼Œå¯¹æ¯ä¸ªç‰©å“ï¼Œéƒ½æ›´æ–°ä¸€æ¬¡dpæ•°ç»„ã€‚ä»å‰å¾€åéå†ï¼Œæ¯æ¬¡éƒ½æ˜¯å¦‚$dp[i] += dp[i - k]$çš„å½¢å¼åˆ©ç”¨æ›´å°ä¸‹æ ‡çš„çŠ¶æ€ï¼Œè¿™æ ·å°±å¯è®©å½“å‰ç‰©å“è¢«é‡å¤åŠ å…¥å¤šæ¬¡ï¼Œä¸é‡ä¸æ¼ï¼Œå› ä¸ºå†æ€ä¹ˆé‡å¤æ·»åŠ å½“å‰ç‰©å“ä¹Ÿåªä¼šå’Œä¸‹æ ‡å°çš„æœ‰å…³ï¼Œä¸”é‡å¤ç‰©å“çš„å…ˆåæ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚[518.Â é›¶é’±å…‘æ¢ II](https://leetcode.cn/problems/coin-change-ii/)

```cpp
int change(int amount, vector<int>& coins) {
	vector<int> dp(amount + 1);
	dp[0] = 1;
	for (int& coin : coins) {
		for (int i = coin; i <= amount; i++) {
			dp[i] += dp[i - coin];
		}
	}
	return dp[amount];
}
```

æ±‚æ’åˆ—çš„æ€»æ•°æ—¶ï¼ŒåŒä¸€ä¸ªç‰©å“ä¸èƒ½å †åœ¨ä¸€èµ·ç®—äº†ï¼Œå¿…é¡»æ¯ä¸ª$dp[i]$éƒ½è€ƒè™‘äº†æ‰€æœ‰æƒ…å†µåï¼Œæ‰èƒ½å°†å…¶ç”¨äºæ›´é åçš„$dp[i]$ã€‚æ­¤æ—¶éå†çš„å±‚æ¬¡é¡ºåºåˆšå¥½ä¸ç»„åˆé—®é¢˜åè¿‡æ¥ã€‚è¿™ç§é—®é¢˜ä¹Ÿèƒ½ç­‰ä»·åœ°çœ‹æˆ**å¯ä»¥èµ°å¤šç§æ­¥æ•°çš„çˆ¬æ¥¼æ¢¯é—®é¢˜**ï¼Œæ¯æ¬¡éƒ½æŠŠæ‰€æœ‰æ­¥æ•°ç§ç±»éå†ä¸€éã€‚[377.Â ç»„åˆæ€»å’Œ â…£](https://leetcode.cn/problems/combination-sum-iv/)

```cpp
int combinationSum4(vector<int>& nums, int target) {
	vector<int> dp(target + 1);
	dp[0] = 1;
	for (int i = 1; i <= target; i++) {
		for (int& num : nums) {
			if (num <= i) {
				dp[i] += dp[i - num];
			}
		}
	}
	return dp[target];
}
```

æ’åˆ—é—®é¢˜ç•¥åŠ å˜å½¢[139.Â å•è¯æ‹†åˆ†](https://leetcode.cn/problems/word-break/)ï¼Œä¸‹é¢ä¸¤ç§è§£æ³•é€»è¾‘ä¸Šç­‰ä»·ï¼š

```cpp
bool wordBreak1(string s, vector<string>& wordDict) {
	auto wordDictSet = unordered_set <string> ();
	for (auto word: wordDict) {
		wordDictSet.insert(word);
	}

	auto dp = vector <bool> (s.size() + 1);
	dp[0] = true;
	for (int i = 1; i <= s.size(); ++i) {
		//ä¸‹é¢çš„jå¾ªç¯ç­‰ä»·äºå°†wordDictä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½è¯•è¿‡å»ï¼Œè®©å‰é¢çš„çŠ¶æ€è½¬ç§»åˆ°åé¢
		//ä½†è¿™æ ·å†™æ›´åŠ ç®€æ´
		for (int j = 0; j < i; ++j) {
			if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
				dp[i] = true;
				break;
			}
		}
	}

	return dp[s.size()];
}

bool wordBreak2(string s, vector<string>& wordDict) {
	vector<int> dp(s.size()+1,false);
	dp[0]=true;
	for(int i=1;i<=s.size();i++){
		for(auto w:wordDict){
			int w_size = w.size();
			if(!dp[i] && i>=w_size){
				dp[i] = dp[i-w_size] && s.substr(i-w_size,w_size) == w;
			}
			if(dp[i]){
				break;
			}
		}
	}

	return dp[s.size()];
}
```

# Floyd

ç»“æœä¸ºå›¾ä¸Šä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

æœ‰ä¸¤ä¸ªçŸ©é˜µï¼Œè®°å½•i->jæœ€çŸ­è·ç¦»çš„DçŸ©é˜µå’Œç”¨äºå›æº¯çš„SçŸ©é˜µï¼Œå°ºå¯¸éƒ½ä¸ºV\*Vã€‚

SçŸ©é˜µå­˜å‚¨æœ€çŸ­è·¯å¾„i->jè¦ç»è¿‡çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚1->5->6->8æ—¶ï¼Œ$S[1][8]=5$ï¼›åˆ™ä¸‹æ¬¡å°±ä¼šå»æ‰¾$S[5][8]$=6ï¼Œç„¶å$S[6][8]=8$ï¼›$8==8$ï¼ŒSçŸ©é˜µå€¼ä¸ç»ˆç‚¹ç›¸åŒï¼Œåˆ™æ˜¯æ‰¾å®Œè·¯å¾„äº†ã€‚

åˆå§‹åŒ–ï¼šéå†æ‰€æœ‰è¾¹(i,jï¼Œlen)ï¼Œ$D[i][j]=len$ ï¼›å¯¹ä»»æ„çš„iï¼Œjï¼Œ$S[i][j]=j$ ã€‚ï¼ˆè¿™é‡Œå¯¹SçŸ©é˜µçš„åˆå§‹åŒ–æ¯”è¾ƒæš´åŠ›ï¼Œå¯èƒ½åœ¨éå¼ºè¿é€šå›¾å†…å‡ºé—®é¢˜ï¼‰

```python
#ä½¿ç”¨æ‰€æœ‰ç»“ç‚¹å»æ¾å¼›å…¶ä»–ç»“ç‚¹
for k in range(self.V):
	#éå†æ‰€æœ‰ç»“ç‚¹ç»„åˆï¼Œè®©å…¶è¢«kç»“ç‚¹æ¾å¼›
	for i in range(self.V):
		for j in range(self.V):
			if self.D[i][j]>self.D[i][k]+self.D[k][j]:
				#æ¾å¼›
				self.D[i][j]=self.D[i][k]+self.D[k][j]
				#å–i->kè·¯å¾„çš„ç¬¬ä¸€ä¸ªé€”å¾„ç»“ç‚¹ä½œä¸ºi->jè·¯å¾„çš„ç¬¬ä¸€ä¸ªé€”å¾„ç»“ç‚¹ 
				self.S[i][j]=self.S[i][k] 
```


# å‰ç¼€å’Œ

```cpp
for(int i=1;i<len;i++){
	a[i]+=a[i-1];
}
```

## å¿«é€Ÿæ±‚è¿ç»­å­æ•°ç»„çš„å’Œ

å¯¹æ•´ä¸ªæ•°ç»„æ±‚å‰ç¼€å’Œå¾—åˆ°æ•°ç»„dï¼Œåˆ™ç¬¬ié¡¹åˆ°ç¬¬jé¡¹è¿™ä¸€å­æ•°ç»„ï¼ˆé•¿åº¦ä¸ºj-i+1ï¼‰çš„å’Œä¸º$d[j]-d[i-1]$ã€‚

## åŒºé—´åŠ åŒä¸€ä¸ªæ•°

éœ€æ±‚ï¼šæœ‰ä¸€ä¸ªå…¨0çš„é•¿åº¦ä¸ºnçš„æ•°ç»„aï¼Œæ¯æ¬¡ä»¤åŒºé—´$[x_i,y_i]$éƒ½åŠ ä¸Š$k_i$ï¼Œå¦‚æ­¤æ“ä½œtæ¬¡ã€‚

æš´åŠ›åŠ çš„æ—¶é—´å¤æ‚åº¦æœ€åä¸º$O(n*t)$ã€‚

å¯ä»¥è®©$a[x_i]+=k_i$ï¼Œ$a[y_i]-=k_i$ï¼›ç„¶åå¯¹aæ±‚å‰ç¼€å’Œ.æ­¤æ—¶å¤æ‚åº¦ä¸º$O(n+t)$ã€‚

# æœ€å°ç”Ÿæˆæ ‘

å¯¹äºæœ‰nä¸ªé¡¶ç‚¹çš„**è¿é€šå›¾**ï¼Œå¿…ç„¶å­˜åœ¨**æå°è¿é€šå­å›¾**ï¼Œå®ƒç”±åŸå›¾çš„æ‰€æœ‰é¡¶ç‚¹å’Œéƒ¨åˆ†è¾¹ç»„æˆï¼Œä¸”æ²¡æœ‰ç¯ï¼›å½“ä»»æ„çš„<u>åŸå›¾ä¸­æœ‰ä½†æå°è¿é€šå­å›¾ä¸­æ²¡æœ‰çš„è¾¹</u>åŠ å…¥æå°è¿é€šå­å›¾ä¸­æ—¶ï¼Œä¼šå‡ºç°ç¯ã€‚æå°è¿é€šå­å›¾åˆå«ç”Ÿæˆæ ‘ã€‚

ç”Ÿæˆæ ‘ä¸­çš„æ‰€æœ‰è¾¹çš„æƒå€¼å’Œæœ€å°æ—¶ï¼Œç§°ä¸º**æœ€å°ç”Ÿæˆæ ‘**ã€‚

## Prim

è®¾ç»“æœç‚¹é›†Uï¼Œå‰©ä½™ç‚¹é›†V-Uã€‚Uåˆå§‹ä¸ºéšæœºä¸€ç‚¹ã€‚å¯¹è¾¹(n1,n2)ï¼Œä¸”n1åœ¨Uä¸­ã€n2åœ¨V-Uä¸­ï¼Œæ±‚æœ€å°çš„è¿™æ ·çš„è¾¹ï¼›ç„¶åå°†è¿™ä¸ªè¾¹ä½œä¸ºç»“æœæ ‘çš„ä¸€éƒ¨åˆ†ï¼Œä¸”å°†n2åŠ å…¥åˆ°Uã€‚

å…·ä½“æ¥è¯´ï¼Œè¦ç»´æŠ¤â€æœªåŠ å…¥çš„å„ä¸ªç‚¹åˆ°ç»“æœæ ‘çš„è·ç¦»â€œè¿™ä¸€æ•°ç»„ã€‚æ¯æ¬¡é€‰å–æ•°ç»„ä¸­æœ€å°çš„ç‚¹ï¼ŒåŠ å…¥åˆ°ç»“æœæ ‘ä¸­ï¼Œå¹¶å¯¹å…¶ä»–æ‰€æœ‰æœªåŠ å…¥çš„ç‚¹è¿›è¡Œæ¾å¼›ã€‚æ—¶é—´å¤æ‚åº¦$O(n^2)$ï¼Œä¸è¾¹æ•°æ— å…³ï¼Œé€‚åˆç¨ å¯†å›¾ã€‚

### æ­£ç¡®æ€§è¯æ˜

é¦–å…ˆï¼ŒPrimèƒ½äº§ç”Ÿç”Ÿæˆæ ‘ã€‚å½’çº³è¯æ˜ï¼š

1. ç»“æœæ ‘åªæœ‰ä¸€ä¸ªç‚¹æ—¶ï¼Œå’Œæœ€å°ç”Ÿæˆæ ‘çš„éƒ¨åˆ†ç›¸åŒã€‚
2. ä¸‹é¢è¯æ˜æ·»åŠ ä¸€æ¡è¾¹åä¾ç„¶ä¸æœ€å°ç”Ÿæˆæ ‘éƒ¨åˆ†ç›¸åŒã€‚**å‡è®¾Primä¸äº§ç”Ÿæœ€å°ç”Ÿæˆæ ‘**ï¼Œåˆ™ï¼šç”±äºPrimäº§ç”Ÿçš„æ˜¯ç”Ÿæˆæ ‘ï¼ˆæˆ–è€…è¯´ç”±äºå…¶ç­–ç•¥ï¼‰ï¼Œæ‰€ä»¥å…¶ä¸Šå¿…ç„¶ä¼šå­˜åœ¨ä¸€æ¡è¾¹$e_j$è¿æ¥Uå’ŒV-Uï¼›åŒç†æœ€å°ç”Ÿæˆæ ‘ä¹Ÿä¼šå­˜åœ¨ä¸€æ¡è¿æ¥çš„è¾¹$e$ã€‚ç”±äºå‡è®¾äº†Primä¸èƒ½ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘ï¼Œå› æ­¤ä¸¤ä¸ªè¾¹ä¸åŒã€‚æ­¤æ—¶ï¼š
	1. å¦‚æœ$e>e_j$ï¼Œåˆ™æœ€å°ç”Ÿæˆæ ‘æ¯”Primçš„ç”Ÿæˆæ ‘è¿˜å¤§ï¼ŒçŸ›ç›¾ã€‚
	2. å¦‚æœ$e=e_j$ï¼Œåˆ™Primäº§ç”Ÿçš„å¿…ç„¶ä¹Ÿæ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚
	3. å¦‚æœ$e<e_j$ï¼Œåˆ™ä¸Primçš„ç­–ç•¥çŸ›ç›¾ã€‚

äºæ˜¯ï¼ŒPrimç”Ÿæˆçš„å¿…ç„¶æ˜¯æœ€å°ç”Ÿæˆæ ‘ã€‚

![350](assets/uTools_1689263800478.png)

## Kruskal

æ¯æ¬¡å°†æœ€å°çš„è¾¹åŠ å…¥åˆ°ç»“æœæ ‘ä¸­ï¼Œä½†ä¸èƒ½å½¢æˆç¯ã€‚

å¯¹æ‰€æœ‰è¾¹è¿›è¡Œæ’åºï¼Œç„¶åä»å°åˆ°å¤§æ’å…¥åˆ°ç»“æœæ ‘ä¸­ï¼›åŒæ—¶ç”¨å¹¶æŸ¥é›†æ£€æµ‹æ˜¯å¦å­˜åœ¨ç¯ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™å–æ¶ˆæ’å…¥å¹¶å°†æ­¤è¾¹ä¸¢å¼ƒï¼ˆç•¥è¿‡ï¼‰ã€‚æœ€å¤§çš„æ—¶é—´å¤æ‚åº¦åœ¨äºæ’åºï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º$O(eloge)$

### æ­£ç¡®æ€§è¯æ˜

å‡è®¾Tæ˜¯ç”¨kruskalæ±‚å‡ºæ¥çš„æœ€å°ç”Ÿæˆæ ‘ï¼Œè€ŒUæ˜¯è¿™ä¸ªå›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚

å‡è®¾T != Uï¼Œé‚£ä¹ˆè‡³å°‘å­˜åœ¨ä¸€æ¡è¾¹åœ¨Tä¸­ï¼Œä¸åœ¨Uä¸­ã€‚é‚£ä¹ˆæˆ‘ä»¬å¸Œæœ›è¯æ˜Tå’ŒUä¸­æ‰€æœ‰è¾¹çš„æƒå€¼ä¹‹å’Œæ˜¯ç›¸ç­‰çš„ã€‚å‡è®¾å­˜åœ¨kæ¡è¾¹å­˜åœ¨Tä¸­ä¸å­˜åœ¨Uä¸­ã€‚ 

æ¥ä¸‹æ¥è¿›è¡Œkæ¬¡å˜æ¢ï¼š æ¯æ¬¡å°†åœ¨Tä¸­ä¸åœ¨Uä¸­çš„æœ€å°çš„è¾¹fæ‹¿å‡ºæ¥æ”¾åˆ°Uä¸­ï¼Œé‚£ä¹ˆUä¸­å¿…ç„¶å½¢æˆä¸€æ¡å”¯ä¸€çš„ç¯è·¯ï¼Œæˆ‘ä»¬å–å‡ºè¿™ä¸ªç¯è·¯ä¸Šæœ€å°çš„ä¸”ä¸å†Tä¸­çš„è¾¹eæ”¾å›åˆ°Tä¸­ä»¥è®©Uå˜å›æœ€å°ç”Ÿæˆæ ‘ã€‚è¿™æ ·çš„è¾¹eä¸€å®šæ˜¯å­˜åœ¨çš„ï¼Œå› ä¸ºå¦‚æœeåŸæ¥å°±åœ¨Tä¸­ï¼Œé‚£ä¹ˆå°±ä¼šå¸¦ä¸Šfå½¢æˆç¯è·¯ï¼Œä½†Tæ˜¯æ²¡æœ‰ç¯è·¯çš„ã€‚ 

ç°åœ¨è¯æ˜få’Œeçš„å…³ç³»ï¼Œå¦‚æœfå’Œeç›¸ç­‰çš„ï¼Œé‚£ä¹ˆkæ¬¡å˜æ¢åï¼ŒTå’ŒUçš„æƒå€¼ä¹‹å’Œæ˜¯ç›¸ç­‰çš„ï¼Œé‚£ä¹ˆè¯æ˜å°±æˆç«‹äº†ã€‚ 

1. å‡è®¾f < e,é‚£ä¹ˆåæ¥å½¢æˆçš„Uæ˜¯æƒå€¼ä¹‹å’Œæ›´å°äº†ï¼Œä¸Uæ˜¯æœ€å°ç”Ÿæˆæ ‘çŸ›ç›¾ã€‚ 
2. å‡è®¾f > e,é‚£ä¹ˆæ ¹æ®kruskalçš„åšæ³•ï¼Œeæ˜¯åœ¨fä¹‹å‰è¢«å–å‡ºæ¥çš„è¾¹ä½†æ˜¯è¢«èˆå¼ƒäº†ï¼Œä¸€å®šæ˜¯å› ä¸ºeå’Œæ¯”eå°çš„è¾¹å½¢æˆäº†ç¯è·¯ï¼Œè€Œæ¯”eå°çš„è¾¹éƒ½æ˜¯å­˜åœ¨Uä¸­çš„ï¼Œè€Œeå’Œè¿™äº›è¾¹å¹¶æ²¡æœ‰å½¢æˆç¯è·¯ï¼Œäºå‡è®¾çŸ›ç›¾ã€‚ 

æ‰€ä»¥f = eã€‚ 


# æ‹“æ‰‘æ’åº

åœ¨ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œæ‰€æœ‰çš„ç‚¹èƒ½è¢«æ‹“æ‰‘æ’åºæˆä¸€ä¸ªåºåˆ—ï¼Œå…¶ä¸­å¦‚æœu->vï¼Œåˆ™uåœ¨vå‰ã€‚

æ­¥éª¤ï¼šæ‰¾åˆ°ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹ï¼Œå°†å…¶æ·»åŠ åˆ°åºåˆ—çš„æœ«ç«¯ï¼Œç„¶ååœ¨å›¾ä¸Šå»æ‰è¯¥ç‚¹å’Œç›¸å…³çš„è¾¹ï¼ˆä½¿å¾—å…¶ä»–ç‚¹çš„å…¥åº¦å‡å°ï¼‰ã€‚å¦‚æ­¤å¾ªç¯ç›´åˆ°æ‰€æœ‰ç‚¹è¢«åŠ å…¥åºåˆ—ã€‚

å…·ä½“å®ç°ä¸­ï¼Œå°†å…¥åº¦ä¸º0çš„ç‚¹éƒ½å­˜å‚¨åœ¨é˜Ÿåˆ—ä¸­ï¼Œæ¯æ¬¡å–å‡ºä¸€ä¸ªè¿›è¡Œä¸€æ¬¡æ“ä½œï¼›åˆ é™¤ä¸€æ¡è¾¹æ—¶ï¼Œå°±æ£€æµ‹æ­¤è¾¹è¿æ¥çš„å¦ä¸€ä¸ªç‚¹æ˜¯å¦å…¥åº¦ä¸º0ï¼Œè‹¥ä¸º0åˆ™å°†å…¶æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ç”¨äºä¸‹ä¸€æ¬¡çš„å¾ªç¯ã€‚

# å…³é”®è·¯å¾„

ä»æºç‚¹åˆ°ç»ˆç‚¹çš„æœ€é•¿è·¯å¾„ã€‚AOEæƒå€¼åœ¨è¾¹ä¸Šï¼ŒAOVæƒå€¼åœ¨ç‚¹ä¸Šã€‚

ä»æºç‚¹åˆ°ç»ˆç‚¹é€šè¿‡æ‹“æ‰‘æ’åºå¾—åˆ°æ‰€æœ‰ç‚¹çš„æœ€æ—©å¼€å§‹æ—¶é—´ï¼Œå†ä»ç»ˆç‚¹åˆ°æºç‚¹é€šè¿‡æ‹“æ‰‘æ’åºå¾—åˆ°æ‰€æœ‰ç‚¹çš„æœ€è¿Ÿå¼€å§‹æ—¶é—´ã€‚ä¸¤è€…ç›¸ç­‰çš„è·¯å¾„å³ä¸ºå…³é”®è·¯å¾„ã€‚

å¯¹AOVæ¥è¯´ï¼Œä¸€ä¸ªç‚¹çš„ç»“æŸæ—¶é—´ç­‰äºä¸‹ä¸€ä¸ªç‚¹çš„å¼€å§‹æ—¶é—´ã€‚è€Œä¸€ä¸ªç‚¹çš„ç»“æŸæ—¶é—´æ¯”å®ƒçš„å¼€å§‹æ—¶é—´å¤§äº†å®ƒçš„æƒå€¼ã€‚å¯¹AOEæ¥è¯´ï¼Œä¸€ä¸ªç‚¹çš„å¼€å§‹å’Œç»“æŸæ—¶é—´å¯è§†ä¸ºç›¸ç­‰ï¼Œä½†ä¸€ä¸ªç‚¹çš„ç»“æŸæ—¶é—´æ¯”ä¸‹ä¸€ä¸ªç‚¹çš„å¼€å§‹æ—¶é—´å°äº†å®ƒçš„æƒå€¼ã€‚

# å‰ç¼€æ ‘ Trie

[Internetè·¯ç”±ä¹‹è·¯ç”±è¡¨æŸ¥æ‰¾ç®—æ³•æ¦‚è¿°-å“ˆå¸Œ/LC-Trieæ ‘/256-way-mtrieæ ‘\_ip mtrie-CSDNåšå®¢](https://blog.csdn.net/armlinuxww/article/details/89370677?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-89370677-blog-115477491.235^v38^pc_relevant_anti_t3&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

ç»å…¸çš„Trieå¦‚ä¸‹ï¼š
```cpp
class TrieNode {
public:
    std::unordered_map<char, TrieNode*> children;
    bool isEndOfWord;

    TrieNode() {
        isEndOfWord = false;
    }
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    void insert(const std::string& word) {
        TrieNode* current = root;
        for (char c : word) {
            if (current->children.find(c) == current->children.end()) {
                current->children[c] = new TrieNode();
            }
            current = current->children[c];
        }
        current->isEndOfWord = true;
    }

    bool search(const std::string& word) {
        TrieNode* current = root;
        for (char c : word) {
            if (current->children.find(c) == current->children.end()) {
                return false;
            }
            current = current->children[c];
        }
        return current->isEndOfWord;
    }
};
```

LC-Trie(Level Compressed Trie)å¯¹å±‚çº§è¿›è¡Œå‹ç¼©ï¼Œç›¸å½“äºæŠŠ**ç¨€ç–æ ‘**ä¸­é—´ä¸å¯èƒ½å‡ºç°å‘½ä¸­çš„åŒºåŸŸç»™å‹ç¼©ï¼Œä»è€Œå‡å°å†…å­˜æ¶ˆè€—ã€‚

>ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå®ƒåªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹ä¸”å·¦å³èŠ‚ç‚¹éƒ½å­˜åœ¨ï¼Œç”¨ä¸¤ä¸ªå­èŠ‚ç‚¹ä»£æ›¿è¿™ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœèŠ‚ç‚¹çš„ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºå¶å­èŠ‚ç‚¹ï¼Œåˆ™åœæ­¢æ›¿æ¢ã€‚
# å¹¶æŸ¥é›†

å¯¹è‹¥å¹²ä¸ªå…ƒç´ è¿›è¡ŒåŒç±»åˆå¹¶ï¼Œæ¯”å¦‚æŠŠæœ‰äº²æˆšå…³ç³»çš„äººéƒ½åˆå¹¶åˆ°åŒä¸€ä¸ªé›†åˆé‡Œé¢ï¼Œå°±èƒ½çŸ¥é“ä¸€ç¾¤äººå¯ä»¥åˆ†ä¸ºå‡ ä¸ªå®¶æ—ã€‚

æ¯ä¸ªå…ƒç´ éƒ½å½’å±äºä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤å¹¶æŸ¥é›†æ˜¯ä¸ªæ£®æ—ï¼›æ¯ä¸ªé›†åˆéƒ½æ˜¯ä¸€ä¸ªæ ‘ï¼›æ¯ä¸ªæ ‘ç»“ç‚¹åªçŸ¥é“å®ƒçš„çˆ¶ç»“ç‚¹ï¼›æ ‘æ ¹ç»“ç‚¹å½’å±äºå®ƒè‡ªå·±ã€‚

## åŸºæœ¬æ­¥éª¤

æ¯ä¸€ä¸ªé›†åˆéƒ½ç”±å…¶æ ‘æ ¹ç»“ç‚¹ä»£è¡¨ã€‚

1. åˆå§‹åŒ–: å°†æ¯ä¸ªå…ƒç´ éƒ½ç‹¬ç«‹åœ°ä½œä¸ºä¸€ä¸ªé›†åˆã€‚
2. åˆå¹¶ï¼ˆunionï¼‰: è‹¥å…ƒç´ aå’Œbæœ‰å…³ç³»ï¼Œåˆ™åˆå¹¶å…¶æ‰€åœ¨é›†åˆã€‚ä»¤bé›†åˆçš„æ ‘æ ¹å½’å±äºaé›†åˆçš„æ ‘æ ¹ã€‚
3. æŸ¥æ‰¾ï¼ˆfindï¼‰: å¯»æ‰¾ä¸€ä¸ªå…ƒç´ çš„æ‰€åœ¨é›†åˆã€‚ä¸€ç›´å‘ä¸ŠæŸ¥å½’å±ç›´åˆ°æ‰¾åˆ°æ ‘æ ¹ã€‚

![300](assets/uTools_1689128872295.png)



## ä¼˜åŒ–

### è·¯å¾„å‹ç¼©

æ ‘çš„ç»“æ„æ˜¯å¯ä»¥ä¿®æ”¹çš„ï¼Œåªè¦æ ‘æ ¹æ­£ç¡®å³å¯ã€‚å› æ­¤ï¼Œåœ¨æŸ¥æ‰¾çš„æ—¶å€™ï¼Œè‹¥aå…ƒç´ å±äºä»¥rå…ƒç´ ä¸ºæ ‘æ ¹çš„é›†åˆï¼Œåˆ™ä»¤aç›´æ¥å½’å±rã€‚æ­¤æ—¶æŸ¥è¯¢çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(logN)$ã€‚

![300](assets/uTools_1689129891643.png)

### æŒ‰ç§©åˆå¹¶

æ­¤å¤„å°†ç§©ï¼ˆrankï¼‰å®šä¹‰ä¸ºæ ‘çš„æ·±åº¦ã€‚åˆå¹¶é›†åˆaå’Œé›†åˆbæ—¶ï¼Œè‹¥açš„æ·±åº¦å°äºç­‰äºbçš„æ·±åº¦ï¼Œåˆ™è®©aæŒ‚åˆ°bçš„æ ‘æ ¹ä¸‹ã€‚å°äºæ—¶ï¼Œç»“æœæ·±åº¦åŒbï¼›ç­‰äºæ—¶ï¼Œç»“æœæ·±åº¦ä¸ºbæ·±åº¦åŠ 1ã€‚å› æ­¤è¦ç»´æŠ¤å¥½æ¯ä¸ªé›†åˆçš„ç§©ï¼Œè¿™æ ·åœ¨åˆå¹¶æ—¶å¯ä»¥å‡†ç¡®è®¡ç®—å‡ºæ–°é›†åˆçš„ç§©è€Œä¸éœ€é‡æ–°éå†æ ‘ã€‚æ­¤æ—¶æŸ¥è¯¢çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(logN)$ã€‚

![300](assets/uTools_1689130262939.png)

![300](assets/uTools_1689130271556.png)

### åŒæ—¶ä½¿ç”¨

ä¸¤è€…ä¹Ÿå¯åŒæ—¶ä½¿ç”¨ï¼Œä½¿å¾—æŸ¥è¯¢çš„å¹³å‡æ—¶é—´å¤æ‚åº¦é™ä¸º$O(\alpha(N))$ï¼Œä¸ºåé˜¿å…‹æ›¼å‡½æ•°ï¼Œå¯è§†ä¸ºå¸¸æ•°ã€‚

è¿‡ç¨‹ä¸­å¯èƒ½ç”±äºè·¯å¾„å‹ç¼©å¯¼è‡´æ ‘çš„æ·±åº¦å‡å°‘ï¼Œæ­¤æ—¶ä¹Ÿæ— éœ€ä¿®æ”¹ç§©ã€‚å¯ä»¥ç†è§£ä¸ºæŒ‰ç§©åˆå¹¶**å°½å¯èƒ½ä¼˜åŒ–äº†åˆå¹¶åçš„å‰å‡ æ¬¡æŸ¥è¯¢**ã€‚

> ä½†æ˜¯è¿™æ ·å¯èƒ½ä¼šå¢åŠ å†…å­˜è´Ÿæ‹…ï¼Œåº”è¯¥ä¸å¤ªå€¼å¾—ã€‚

### åº”ç”¨

#### è¿é€šæ€§

[LeetCode 547 çœä»½æ•°é‡](https://leetcode.cn/problems/number-of-provinces)

```cpp
class UnionFind {
public:
    UnionFind(const int n) {
        count = n;
        parent = vector<int>(n);
        // ç§©çš„ç»å¯¹å¤§å°æ²¡æœ‰æ„ä¹‰ï¼Œå¯ä»¥ç›´æ¥è®¾ä¸º0(æ ‘æ ¹)
        rank = vector<int>(n, 0);
        
        for (int i = 0; i < n; ++i) {
            // åˆšå¼€å§‹æ—¶æ¯ä¸ª1éƒ½ç‹¬ç«‹æˆæ ‘ï¼Œå½’å±äºè‡ªå·±
            parent[i] = i;
        }
    }

    int find(int i) {
        if (parent[i] != i) {
	        //æŸ¥æ‰¾çš„åŒæ—¶è¿›è¡Œè·¯å¾„å‹ç¼©
          parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    void unite(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
	        //åˆå¹¶åˆ°å¤§ç§©çš„æ ‘é‡Œé¢å»
          if (rank[rootx] < rank[rooty]) {
              swap(rootx, rooty);
          }
          parent[rooty] = rootx;
          //ç­‰ç§©ä¼šå¯¼è‡´æ·±åº¦å¤šä¸€ä¸ª
          if (rank[rootx] == rank[rooty]) {
              rank[rootx] += 1;
          }
          count--;
        }
    }

    int getCount() const {
        return count;
    }

private:
    int count;
    vector<int> parent;
    vector<int> rank;
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        auto uf = UnionFind(n);

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(isConnected[i][j] == 1) {
                    uf.unite(i, j);
                }
            }
        }

        auto ans = uf.getCount();
        return ans;
    }
};
```

[LeetCode 200 å²›å±¿æ•°é‡](https://leetcode.cn/problems/number-of-islands/)

```cpp
class UnionFind {
public:
    UnionFind(vector<vector<char>>& grid) {
        count = 0;
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
	                //åˆšå¼€å§‹æ—¶æ¯ä¸ª1éƒ½ç‹¬ç«‹æˆæ ‘ï¼Œå½’å±äºè‡ªå·±
                    parent.push_back(i * n + j);
                    ++count;
                }
                else {
                    parent.push_back(-1);
                }
                //ç§©çš„ç»å¯¹å¤§å°æ²¡æœ‰æ„ä¹‰ï¼Œå¯ä»¥ç›´æ¥è®¾ä¸º0
                rank.push_back(0);
            }
        }
    }

    int find(int i) {
        if (parent[i] != i) {
	        //æŸ¥æ‰¾çš„åŒæ—¶è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    void unite(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
	        //åˆå¹¶åˆ°å¤§ç§©çš„æ ‘é‡Œé¢å»
            if (rank[rootx] < rank[rooty]) {
                swap(rootx, rooty);
            }
            parent[rooty] = rootx;
            //ç­‰ç§©ä¼šå¯¼è‡´æ·±åº¦å¤šä¸€ä¸ª
            if (rank[rootx] == rank[rooty]) rank[rootx] += 1;
            --count;
        }
    }

    int getCount() const {
        return count;
    }

private:
    vector<int> parent;
    vector<int> rank;
    int count;
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        UnionFind uf(grid);
        int num_islands = 0;
        //è¿™é‡Œä¸éœ€è¦ä¸Šä¸‹å·¦å³éƒ½çœ‹ç€uniteã€‚ç”±äºæ˜¯ä»å·¦ä¸Šéå†åˆ°å³ä¸‹ï¼Œå› æ­¤åªè¦åˆå¹¶å·¦è¾¹å’Œä¸Šè¾¹å°±è¡Œäº†ã€‚
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') uf.unite(r * nc + c, (r-1) * nc + c);
                    if (r + 1 < nr && grid[r+1][c] == '1') uf.unite(r * nc + c, (r+1) * nc + c);
                    if (c - 1 >= 0 && grid[r][c-1] == '1') uf.unite(r * nc + c, r * nc + c - 1);
                    if (c + 1 < nc && grid[r][c+1] == '1') uf.unite(r * nc + c, r * nc + c + 1);
                }
            }
        }

        return uf.getCount();
    }
};
```

#### æ£€æµ‹ç¯

åˆå§‹æ—¶å›¾ä¸Šæ¯ä¸ªç‚¹éƒ½ç‹¬ç«‹ä¸ºä¸€ä¸ªé›†åˆã€‚å¦‚æœåŒä¸€é›†åˆå†…çš„ä¸¤ä¸ªç‚¹åˆè¢«åˆå¹¶ï¼Œåˆ™è¯´æ˜æœ‰ç¯ã€‚æ­¤æ—¶ç›¸å½“äºaç‚¹å’Œbç‚¹å·²ç»é€šè¿‡æ ¹ç»“ç‚¹cè¿é€šï¼Œä½†è¿˜æ˜¯æœ‰å…¶ä»–è¿é€šè·¯å¾„ï¼Œåˆ™å¿…ç„¶å­˜åœ¨ç¯ã€‚

# å•è°ƒæ ˆ

[84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ é¢˜è§£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/)

ç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œä½¿å¾—å…¥æ ˆå‰ï¼Œè‹¥æ ˆé¡¶æ¯”å…¥æ ˆå…ƒç´ å¤§ï¼ˆæˆ–å°ï¼‰ï¼Œåˆ™è¿›è¡Œå¼¹æ ˆï¼Œç›´åˆ°æ ˆé¡¶å…ƒç´ æ¯”å…¥æ ˆå…ƒç´ å°ï¼ˆæˆ–å¤§ï¼‰ä¸ºæ­¢ã€‚ä½¿å¾—æ ˆåº•åˆ°æ ˆé¡¶é€’å¢ï¼ˆæˆ–é€’å‡ï¼‰ã€‚æ¯ä¸ªå…ƒç´ çš„å…¥æ ˆå’Œå‡ºæ ˆéƒ½å¯ä»¥è§¦å‘ä¸€äº›äº‹ä»¶ã€ç»“æœã€‚

# å•è°ƒé˜Ÿåˆ—

[239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼ é¢˜è§£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/) æ–¹æ³•2

åœ¨é˜Ÿå°¾æ’å…¥å…ƒç´ å‰ï¼Œå°†é˜Ÿå°¾æ¯”è‡ªå·±å°çš„å…ƒç´ éƒ½å¼¹å‡ºæ¥ã€‚è¿™ä½¿å¾—ä»é˜Ÿé¦–åˆ°é˜Ÿå°¾å•è°ƒé€’å‡ã€‚

# æœ€å¤§å€¼æœ€å°åŒ–&æœ€å°å€¼æœ€å¤§åŒ–

æ‹¿æœ€å¤§å€¼æœ€å°åŒ–æ¥è®¨è®ºï¼Œå…¶ç­‰ä»·äºæ±‚æŸä¸ªå€¼$k\in [begin,end]$ï¼Œåœ¨æ»¡è¶³$f(k)$æ—¶çš„æœ€å°å€¼ï¼Œ$f(k)$å³ä¸ºâ€œæœ€å€¼â€æ³›å‡½ã€‚ è¿™ç±»é—®é¢˜ä¸­ï¼Œ$f(k)$é€šå¸¸å­˜åœ¨ä¸€ä¸ªä¸´ç•Œç‚¹hï¼Œä½¿å¾—$k<h \rightarrow f(k) \wedge k \geq h \rightarrow f(k)$ ï¼Œè¿™å’Œâ€œåœ¨æœ‰åºæ•°åˆ—ä¸­æŸ¥æ‰¾å¤§äºæŸä¸ªå€¼çš„æœ€å°æ•°â€æ˜¯ç­‰ä»·çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¯ä»¥åœ¨$[begin,end]$ä¸Šä½¿ç”¨äºŒåˆ†æ³•æ±‚è§£ã€‚

ä½¿ç”¨äºŒåˆ†æ³•éå†æœ€å€¼ï¼Œæ£€æŸ¥é‡åˆ°çš„å„ä¸ªå€¼æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œç›´åˆ°æ‰¾åˆ°ä¸´ç•Œç‚¹ã€‚æ—¶é—´å¤æ‚åº¦$O(n)=log(A)*time(check\_function)$ã€‚

[2439.Â æœ€å°åŒ–æ•°ç»„ä¸­çš„æœ€å¤§å€¼](https://leetcode.cn/problems/minimize-maximum-of-array/)

```rust
pub fn minimize_array_value(nums: Vec<i32>) -> i32 {
	let mut left = 0;
	let mut right = nums.iter().max().unwrap().clone();
	let mut mid = -1;
	//äºŒåˆ†æ³•å¯»æ‰¾æœ€å°çš„èƒ½é€šè¿‡checkçš„æ•°å­—ï¼Œæ€»å¤æ‚åº¦ä¸ºO(n*logA)ï¼ŒAä¸ºæ•°ç»„æœ€å¤§æœ€å°å€¼çš„å·®
	while(left<right){
		mid = left+(right-left)/2;
		if Self::check(&nums,mid){
			right = mid;
		}else{
			left = mid+1;
		}
	}
	left
}

//æ£€æŸ¥kæ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œå¤æ‚åº¦ä¸ºO(n)
fn check(nums: &Vec<i32> , k: i32) -> bool{
	let mut have: i64 = 0;
	for n in nums.iter(){
		//çœ‹çœ‹èƒ½å¸®å¿™å¡«è¡¥å¤šå°‘ï¼Œæœ‰å‰©åˆ™ç›ˆï¼Œæ²¡å‰©åˆ™äº
		have += (&k-n) as i64;
		//éå†åˆ°çš„nçš„å‰é¢è¿™éƒ¨åˆ†æ•°ç»„å·²ç»å‹åŠ›çˆ†ç‚¸ï¼Œåˆ™å¤±è´¥
		if have<0{
			return false;
		}
	}
	return true;
}
```

# å¼—æ´›ä¼Šå¾·å¾ªç¯æŸ¥æ‰¾ç®—æ³•

ç›®çš„ï¼šæ£€æµ‹å•å‘ã€ä¸å¯ä¸€å¯¹å¤šçš„é“¾è¡¨ä¸Šçš„ç¯ã€‚

å¿«æ…¢æŒ‡é’ˆéƒ½ä»èµ·ç‚¹å‡ºå‘ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªã€‚è‹¥æ— ç¯ï¼Œåˆ™å¿«æŒ‡é’ˆä¼šç¢°åˆ°æœ«ç«¯ï¼›è‹¥æœ‰ç¯ï¼Œåˆ™ä¸¤ä¸ªæŒ‡é’ˆä¼šç›¸é‡ã€‚æ—¶é—´åœ¨$O(n)$å†…ã€‚

[202. å¿«ä¹æ•° é¢˜è§£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/)çš„é¢˜è§£2æœ‰åŠ¨ç”»æ¼”ç¤ºã€‚


# å°æŠ€å·§

## å‡åŒ€æ˜ å°„

ä½¿ç”¨Fisher-Yatesæ´—ç‰Œç®—æ³•å¯ä»¥å®ç°å°†ä¸€ä¸ªæ•°æ®å‡åŒ€æ´—ç‰Œï¼š
```cpp
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>

std::vector<int> shuffleMapping(int N) {
    std::vector<int> mapping(N);
    for (int i = 0; i < N; i++) {
        mapping[i] = i;
    }
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int i = N - 1; i > 0; i--) {
        std::uniform_int_distribution<int> dis(0, i);
        int j = dis(gen);
        std::swap(mapping[i], mapping[j]);
    }
    return mapping;
}

int main() {
    int N = 10; // ä½ çš„Nå€¼
    std::vector<int> result = shuffleMapping(N);
    for (int i = 0; i < N; i++) {
        std::cout << result[i] << " ";
    }
    return 0;
}
```


# æ‚è®°

è¿½æ±‚è¾“å‡ºæ•ˆç‡æ—¶ä¸è¦ç”¨endlã€‚

å¤šå±‚forå¾ªç¯æ—¶å°¤å…¶è¦æ³¨æ„å±€éƒ¨æ€§ï¼ˆä½¿å¾—ç®—æ³•å¯¹cacheå‹å¥½ï¼‰ï¼Œæ¯”å¦‚ä½¿ç”¨ä¸´æ—¶å˜é‡å¤åˆ¶å†…å­˜æ•°æ®ä»¥å¤šæ¬¡è¯»ï¼›ä¹Ÿè¦æ³¨æ„å‡å°‘å†…å­˜è®¿é—®æ¬¡æ•°ï¼Œæ¯”å¦‚ä½¿ç”¨ä¸´æ—¶å˜é‡å¤åˆ¶å†…å­˜æ•°æ®è¿›è¡Œå¤šæ¬¡å†™ï¼Œç„¶åæŠŠç»“æœå†™å›å†…å­˜ã€‚
































