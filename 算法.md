# 堆

## 建堆

指从无序数组建立堆。

两种方式：向下调整法和向上调整法。

- 无论是哪种调整法，其最坏情况就是调整直至碰顶或底。
- 都是从根节点开始往后遍历。

向下调整，越高的点调整的次数越多，同时越高的点总数越少，复杂度为O(n)。

向上调整，越低的点调整的次数越多，同时越低的点总数越多，复杂度为O(nlogn)。

因此，向下调整更优。

## 调整

一般每次只有一个结点破坏了堆，而只调整这个结点就能重塑堆。复杂度为O(logn)。


# 快排

双指针。把标记拿走。 左边找小于标记的，右边找大于标记的，交换。不断移动直到双指针相撞，此时相撞的左边都是比标记小的，右边都是比标记大的。最后交换标记和相撞点即可。

>相撞有两种情形：
>先移动的指针到达其目标后等待，被后移动的撞上；
>后移动的指针交换完毕后，被下一轮先移动的撞上。
>这两种情形相撞的点都是满足先移动指针目标的点。
>
>因此：
>当选取最左边的元素为基准元素时，先移动的指针一定要是右边的指针（撞在小于目标处）。
>当选取最右边的元素为基准元素时，先移动的指针一定要是左边的指针（撞在大于目标处）。

# Floyd

结果为图上任意两个点之间的最短路径。

有两个矩阵，记录i->j最短距离的D矩阵和用于回溯的S矩阵，尺寸都为V\*V。

S矩阵存储最短路径i->j要经过的第一个节点。如1->5->6->8时，$S[1][8]=5$；则下次就会去找$S[5][8]$=6，然后$S[6][8]=8$；$8==8$，S矩阵值与终点相同，则是找完路径了。

初始化：遍历所有边(i,j，len)，$D[i][j]=len$ ；对任意的i，j，$S[i][j]=j$ 。（这里对S矩阵的初始化比较暴力，可能在非强连通图内出问题）

```python
#使用所有结点去松弛其他结点
for k in range(self.V):
	#遍历所有结点组合，让其被k结点松弛
	for i in range(self.V):
		for j in range(self.V):
			if self.D[i][j]>self.D[i][k]+self.D[k][j]:
				#松弛
				self.D[i][j]=self.D[i][k]+self.D[k][j]
				#取i->k路径的第一个途径结点作为i->j路径的第一个途径结点 
				self.S[i][j]=self.S[i][k] 
```



# 区间加同一个数

需求：有一个全0的长度为n的数组a，每次令区间$[x_i,y_i]$都加上$k_i$，如此操作t次。

暴力加的时间复杂度最坏为$O(n*t)$。

可以让$a[x_i]+=k_i$，$a[y_i]-=k_i$；然后对a求前缀和，即从小到大遍历i，$a[i]+=a[i-1]$。此时复杂度为$O(n+t)$。

# 杂记

追求输出效率时不要用endl。


































