



# 层 TODO



# TCP

TCP报文格式:
![](assets/Pasted%20image%2020250302222637.png)

TCP的 **序列号(sequence numbers, seqnos)** 使用32位(循环), 一个byte一个序列号; SYN和FIN都各占用一个序列号. 刚开始的序列号是使用 Initial Sequence Number (ISN) <u>随机初始化</u>的, 它也即是SYN的序列号. 一个TCP链接有两个方向的两个流, 各自有<u>独立</u>的seqnos和ISN. 
- **绝对序列号(absolute seqno)** 指从零开始的无循环的序列号.
- **流索引(stream indices)** 指不考虑SYN和FIN的 absolute seqno, 只考虑字节.

由于窗口最大大小不超过序列号的32位的中间点, 因此循环序列号不会出现歧义 (比大小方面不会出现歧义) (可以随着报文的接收不断更新一个绝对序列号参考值, 即可将其还原为绝对序列号).

ACK标志位指示确认号是否合法. 因此, 可以在**完全没有Receiver**的情况下发送报文, 只要声明<u>ACK非法</u>即可. 相反, <u>序列号必需合法</u>, 因此**Sender要有创建空内容报文**的功能.


## Sender & Receiver

TCP有两个方向, 各有一对Sender和Receiver.
- **Sender:
    - 负责发送**应用层数据**（如HTTP请求、文件内容等）。
    - 需要处理**序列号（SEQ）**、重传、拥塞控制（`cwnd`）和流量控制（`rwnd`）。
- **Receiver:
    - 负责接收对端发来的数据，并生成**ACK确认报文**。
    - 需要管理**接收窗口**、乱序重组和校验数据完整性。

> [!info]
>  outstanding segments 指 发出去但未确认的段.

TCP Receiver 第一次接收到待SYN的报文后, 就会以此序列号作为该流的ISN. 

TCP Receiver 只会接收窗口范围内的数据, 确认了才会接着移动窗口. 使用ACK+窗口大小即可确定**窗口范围**. **窗口大小**取决于其与<u>应用程序</u>间的<u>缓冲区剩余空间大小</u>, 如果应用程序消耗数据缓慢的话, 窗口大小会缩减.

> [!note]
> 由于SYN和FIN会占用序列号, 因此它们也就会占用窗口.

TCP Sender 从其与应用程序间的缓冲区中读取数据. 只要能发数据(存在待发送数据且<u>窗口未满</u>)就接着发. 刚开始的时候就假设对方Receiver的窗口大小为1.

> [!info]
> "窗口的使用量"被定义为"outstanding segments 的大小". 当**窗口已满**时, 相当于可以发的数据都发了, 但还没收到ACK; 于是此时<u>不能发送新数据</u>, 在收到新ACK之前都只能依据ARQ机制再重新发送outstanding segments.

TCP Sender 对 *占有了序列号的* outstanding segments 进行追踪, 从而超时重传, 即 **automatic repeat request (ARQ)**. 
- 使用**retransmission timeout (RTO)** 变量作为超时重传的时间, 且其<u>初值</u>在TCP创建时就<u>固定</u>下来了.
- 当且仅当有outstanding segments时, 才会计时.
- 超时后, 从最早的outstanding segments开始进行发送, 并且在*窗口大小非0*的情况下启动<u>指数退避(exponential backoff), 将RTO翻倍</u>, 然后重新计时.
- 接收到对<u>新数据的ACK</u>后, **重置**RTO为其初值, 若还有outstanding segments的话就重新计时.
- 可以统计在接收到ACK之前连续的重传包次数, 触发一定次数后即可认为连接情况过差, 可以断开连接.

由于Receiver的<u>窗口大小信息</u>仅在接收到数据后才能对外发送, 因此*Sender*为了**及时更新窗口大小**, 可以在窗口大小为0的时候, <u>假装其是1</u>, 就可以发送非常小的"检测报文"去尝试更新窗口大小.

每次发送的数据量由以下因素共同决定：
- **发送窗口（Send Window）**：取接收方可用窗口（Advertised Window）和拥塞窗口（Congestion Window）的较小值。
- **MSS（Maximum Segment Size）**：单个TCP报文段的最大数据量（通常由MTU决定，如以太网中为1460字节）。
优先发送满MSS的数据段. 剩下的小数据就要考虑<u>糊涂窗口综合征</u>.

**糊涂窗口综合征（Silly Window Syndrome, SWS）** 发生于过小的窗口或过小的可用数据:
- **接收方SWS**：接收方处理数据缓慢，每次仅腾出极小窗口（如1字节），导致发送方只能发送小段。
	- *解决方案*: 在窗口太小的时候告知窗口大小为0.
- **发送方SWS**：发送方应用频繁生成小数据（如逐字节写入），未合并直接发送。
	- *解决方案*: **Nagle算法**：合并小数据段，只有在 已收到之前所有数据的ACK **或** 累积数据达到MSS 时才会发送：

在同一端中, Receiver的回复和Sender的响应可以合为一个报文一起发送, 称做**捎带(piggybacking)**.

## 粘包拆包

TCP本身是面向字节流的, 没有包概念. 因此应用层分别发送的"包"可能被合并或拆分.

- 粘包: 过小的多个包可能被合并起来一起发送.
- 拆包: 包过大, 被分成多次发送.

因此, 需要在上层手动指定包格式, 例如增加头部元数据或尾部分隔符, 或使用使用固定长度数据包, 从而在<u>假设随机分批到达的流</u>当中取出各个包.


## 三次握手 TODO














