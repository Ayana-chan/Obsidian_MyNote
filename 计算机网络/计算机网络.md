



# 层 TODO



# TCP

TCP报文格式:
![](assets/Pasted%20image%2020250302222637.png)

TCP的 **序列号(sequence numbers, seqnos)** 使用32位(循环), 一个byte一个序列号; SYN和FIN都各占用一个序列号. 刚开始的序列号是使用 Initial Sequence Number (ISN) <u>随机初始化</u>的, 它也即是SYN的序列号. 一个TCP链接有两个方向的两个流, 各自有<u>独立</u>的seqnos和ISN. 
- **绝对序列号(absolute seqno)** 指从零开始的无循环的序列号.
- **流索引(stream indices)** 指不考虑SYN和FIN的 absolute seqno, 只考虑字节.

由于窗口最大大小不超过序列号的32位的中间点, 因此循环序列号不会出现歧义 (比大小方面不会出现歧义) (可以随着报文的接收不断更新一个绝对序列号参考值, 即可将其还原为绝对序列号).

ACK标志位指示确认号是否合法. 因此, 可以在**完全没有Receiver**的情况下发送报文, 只要声明<u>ACK非法</u>即可. 相反, <u>序列号必需合法</u>, 因此**Sender要有创建空内容报文**的功能.


## Sender & Receiver

TCP有两个方向, 各有一对Sender和Receiver.
- **Sender:
    - 负责发送**应用层数据**（如HTTP请求、文件内容等）。
    - 需要处理**序列号（SEQ）**、重传、拥塞控制（`cwnd`）和流量控制（`rwnd`）。
- **Receiver:
    - 负责接收对端发来的数据，并生成**ACK确认报文**。
    - 需要管理**接收窗口**、乱序重组和校验数据完整性。

> [!info]
>  outstanding segments 指 发出去但未确认的段.

TCP Receiver 第一次接收到带SYN的报文后, 就会以此序列号作为该流的ISN. 

TCP Receiver 只会接收窗口范围内的数据, 确认了才会接着移动窗口. 使用ACK+窗口大小即可确定**窗口范围**. **窗口大小**取决于其与<u>应用程序</u>间的<u>缓冲区剩余空间大小</u>, 如果应用程序消耗数据缓慢的话, 窗口大小会缩减.

> [!note]
> 由于SYN和FIN会占用序列号, 因此它们也就会占用窗口.

TCP Sender 从其与应用程序间的缓冲区中读取数据. 只要能发数据(存在待发送数据且<u>窗口未满</u>)就接着发. 刚开始的时候就假设对方Receiver的窗口大小为1.

> [!info]
> "窗口的使用量"被定义为"outstanding segments 的大小". 当**窗口已满**时, 相当于可以发的数据都发了, 但还没收到ACK; 于是此时<u>不能发送新数据</u>, 在收到新ACK之前都只能依据ARQ机制再重新发送outstanding segments.

TCP Sender 对 *占有了序列号的* outstanding segments 进行追踪, 从而超时重传, 即 **automatic repeat request (ARQ)**. 
- 使用**retransmission timeout (RTO)** 变量作为超时重传的时间, 且其<u>初值</u>在TCP创建时就<u>固定</u>下来了.
- 当且仅当有outstanding segments时, 才会计时.
- 超时后, 从最早的outstanding segments开始进行发送, 并且在*窗口大小非0*的情况下启动<u>指数退避(exponential backoff), 将RTO翻倍</u>, 然后重新计时.
- 接收到对<u>新数据的ACK</u>后, **重置**RTO为其初值, 若还有outstanding segments的话就重新计时.
- 可以统计在接收到ACK之前连续的重传包次数, 触发一定次数后即可认为连接情况过差, 可以断开连接.

> [!note]
> 刚开始假设对方Receiver的窗口大小为1, 使得最初的SYN丢包时, 也能触发RTO.

由于Receiver的<u>窗口大小信息</u>仅在接收到数据后才能对外发送, 因此*Sender*为了**及时更新窗口大小**, 可以在窗口大小为0的时候, <u>假装其是1</u>, 就可以发送非常小的"检测报文"去尝试更新窗口大小.

每次发送的数据量由以下因素共同决定：
- **发送窗口（Send Window）**：取接收方可用窗口（Advertised Window）和拥塞窗口（Congestion Window）的较小值。
- **MSS（Maximum Segment Size）**：单个TCP报文段的最大数据量（通常由MTU决定，如以太网中为1460字节）。
优先发送满MSS的数据段. 剩下的小数据就要考虑<u>糊涂窗口综合征</u>.

**糊涂窗口综合征（Silly Window Syndrome, SWS）** 发生于过小的窗口或过小的可用数据:
- **接收方SWS**：接收方处理数据缓慢，每次仅腾出极小窗口（如1字节），导致发送方只能发送小段。
	- *解决方案*: 在窗口太小的时候告知窗口大小为0.
- **发送方SWS**：发送方应用频繁生成小数据（如逐字节写入），未合并直接发送。
	- *解决方案*: **Nagle算法**：合并小数据段，只有在 已收到之前所有数据的ACK **或** 累积数据达到MSS 时才会发送：

在同一端中, Receiver的回复和Sender的响应可以合为一个报文一起发送, 称做**捎带(piggybacking)**.

## 粘包拆包

TCP本身是面向字节流的, 没有包概念. 因此应用层分别发送的"包"可能被合并或拆分.

- 粘包: 过小的多个包可能被合并起来一起发送.
- 拆包: 包过大, 被分成多次发送.

因此, 需要在上层手动指定包格式, 例如增加头部元数据或尾部分隔符, 或使用使用固定长度数据包, 从而在<u>假设随机分批到达的流</u>当中取出各个包.


## 三次握手 TODO



## 传递TCP包的几种方式


- TCP in UDP in IP: 使用**UDPSocket**, 只要提供了数据(payload), 就能自动生成UDP, IP和以太网的头. 在这payload中放入TCP报文即可.
- TCP in IP: 普通的TCP/IP形式. 使用**TUN设备**, 它允许应用程序提供完整的因特网报文, 然后自动生成以太网头; 可以认为是交换<u>IP报文</u>的接口. 这就要求应用程序自己负责IP头的生成.
- TCP in IP in Ethernet: 使用**TAP设备**, 是交换<u>以太网报文</u>的接口. 这就要求应用程序自己负责以太网头.


# 数据链路层

数据链路层地址就是MAC.

以太网(Ethernet)帧:
![](assets/Pasted%20image%2020250304234638.png)

广播地址是`ff:ff:ff:ff:ff:ff`.

## ARP Address Resolution Protocol

1. 为了访问目标IP的主机, 就要当知道其对应的MAC地址.
2. 当本地ARP缓存没有目标时, 使用ARP进行广播查询. 广播范围是<u>本地网络</u>, 且只有符合目标IP的主机才会应答(其他主机都丢弃). 
3. 应答主机也会记录源主机的ARP信息(MAC-IP)(其他主机不缓存).
4. 应答主机返回其ARP信息.
5. 源主机收到ARP回复, 更新信息. 信息有生存期, 会过期.

ARP报文被放在以太网的payload当中(就像IP报文被放在里面一样), 然后设置以太网报文首部的类型部分为ARP标记.

ARP报文:
![](assets/Pasted%20image%2020250304231945.png)

> [!note]
> 可见网络接口需要支持:
> 1. 发送IP数据包, 如果不知道目标MAC地址则转而发送ARP.
> 2. 接收IP数据包.
> 3. 接收ARP响应, 以更新ARP缓存, 并及时发送相关的等待队列中的请求.
> 4. 接收ARP请求, 在更新ARP缓存的同时进行自己的ARP信息的响应.

> [!info]
> 网络接口根据 数据包的<u>目标MAC</u>部分 , 当其<u>同时满足</u>下面的条件时, 直接**丢弃**数据包:
> 1. 非广播(广播用于ARP请求).
> 2. 非自己.

为了防止ARP泛滥, 一个请求端需要限制: 对于同一个地址, 在几秒钟只能发送一次ARP(请求合并).

如果ARP<u>一直无响应</u>, 则源主机会发送 host unreachable 的**ICMP**给最初的请求发送者.



























