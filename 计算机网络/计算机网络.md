



# 层

OSI 模型 和 TCP/IP模型 **对应关系**:
  - OSI 应用层 ≈ TCP/IP 应用层（含会话层、表示层功能）  
  - OSI 传输层 ≈ TCP/IP 传输层  
  - OSI 网络层 ≈ TCP/IP 网络层  
  - OSI 数据链路层+物理层 ≈ TCP/IP 网络接口层

## OSI

OSI（开放系统互联）模型 七层结构:

1. **物理层（Physical Layer）**
	- *功能*：传输原始比特流，定义物理介质（电缆、光纤、无线频率）的电气、机械特性。  
	- *技术/协议*：  
	  - 物理介质：双绞线（Cat5/6）、光纤、Wi-Fi（802.11射频）  
	  - 编码技术：曼彻斯特编码、QAM调制  
	  - 设备：中继器（Repeater）、集线器（Hub）
2. **数据链路层（Data Link Layer）**
	- *功能*：在直接相连的设备间传输数据帧，通过MAC地址寻址，实现可靠的点对点通信。  
	- *技术/协议*：  
	  - 以太网（Ethernet, IEEE 802.3）  
	  - MAC地址（如 `00:1A:2B:3C:4D:5E`）  
	  - ARP（地址解析协议）、VLAN（虚拟局域网）  
	  - 设备：交换机（Switch）、网桥（Bridge）
3. **网络层（Network Layer）**
	- *功能*：跨网络路由数据包，选择最佳路径，实现逻辑寻址（IP地址）。  
	- *技术/协议*：  
	  - IP协议（IPv4/IPv6）  
	  - 路由协议：RIP、OSPF、BGP  
	  - ICMP（用于网络诊断，如 `ping`）  
	  - 设备：路由器（Router）
4. **传输层（Transport Layer）**
	- *功能*：提供端到端（进程到进程）的可靠或不可靠数据传输，管理流量控制、错误恢复。  
	- *技术/协议*：  
	  - TCP（可靠传输，三次握手，如网页、文件传输）  
	  - UDP（不可靠传输，低延迟，如视频流、DNS查询）  
	  - 端口号（如 HTTP-80、HTTPS-443）
5. **会话层（Session Layer）**
	- *功能*：建立、管理、终止应用程序之间的会话（连接），同步数据交换。  
	- *技术/协议*：  
	  - NetBIOS（局域网会话管理）  
	  - RPC（远程过程调用）  
	  - SIP（VoIP会话控制）
6. **表示层（Presentation Layer）**
	- *功能*：数据格式转换（编码、加密、压缩），确保不同系统间的数据兼容性。  
	- *技术/协议*：  
	  - SSL/TLS（加密/解密）  
	  - JPEG/MPEG（图像/视频编码）  
	  - ASCII/Unicode（字符编码）
7. **应用层（Application Layer）**
	- *功能*：为应用程序提供网络服务接口，直接面向用户。  
	- *技术/协议*：  
	  - HTTP（网页访问）  
	  - FTP（文件传输）  
	  - SMTP/POP3（电子邮件）  
	  - DNS（域名解析）  
	  - SSH（安全远程登录）


## TCP/IP

1. **网络接口层 (Network Interface Layer)**
	- *功能*：负责在物理网络上发送和接收数据帧，处理物理地址（如MAC地址）。
	- *技术名*：以太网（Ethernet）、Wi-Fi（IEEE 802.11）、PPP（点对点协议）、ARP（地址解析协议）等。
2. **网络层 (Internet Layer)**
	- *功能*：负责数据包的路由选择和转发，处理逻辑地址（如IP地址）。
	- *技术名*：IP（互联网协议，包括IPv4和IPv6）、ICMP（互联网控制消息协议）、IGMP（互联网组管理协议）等。
3. **传输层 (Transport Layer)**
	- *功能*：提供端到端的通信，确保数据的完整性和顺序，处理流量控制和错误恢复。
	- *技术名*：TCP（传输控制协议）、UDP（用户数据报协议）、SCTP（流控制传输协议）等。
4. **应用层 (Application Layer)**
	- *功能*：为用户提供网络服务，直接与用户交互，处理应用程序之间的通信。
	- *技术名*：HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名系统）、Telnet等。



# 数据链路层

数据链路层地址就是MAC.

以太网(Ethernet)帧:
![](assets/Pasted%20image%2020250304234638.png)

广播地址是`ff:ff:ff:ff:ff:ff`.

## ARP Address Resolution Protocol

1. 为了访问目标IP的主机, 就要当知道其对应的MAC地址.
2. 当本地ARP缓存没有目标时, 使用ARP进行广播查询. 广播范围是<u>本地网络</u>, 且只有符合目标IP的主机才会应答(其他主机都丢弃). 
3. 应答主机也会记录源主机的ARP信息(MAC-IP)(其他主机不缓存).
4. 应答主机返回其ARP信息.
5. 源主机收到ARP回复, 更新信息. 信息有生存期, 会过期.

ARP报文被放在以太网的payload当中(就像IP报文被放在里面一样), 然后设置以太网报文首部的类型部分为ARP标记.

ARP报文:
![](assets/Pasted%20image%2020250304231945.png)

> [!note]
> 在TCP/IP中, ARP属于"网络接口层".

> [!note]
> 可见网络接口需要支持:
> 1. <u>指定IP地址</u>(可能是目标主机, 也可能是下一跳路由器), 发送IP数据包, 如果不知道目标MAC地址则转而发送ARP.
> 2. 接收IP数据包.
> 3. 接收ARP响应, 以更新ARP缓存, 并及时发送相关的等待队列中的请求.
> 4. 接收ARP请求, 在更新ARP缓存的同时进行自己的ARP信息的响应.

> [!info]
> 网络接口根据 数据包的<u>目标MAC</u>部分 , 当其<u>同时满足</u>下面的条件时, 直接**丢弃**数据包:
> 1. 非广播(广播用于ARP请求).
> 2. 非自己.

为了防止ARP泛滥, 一个请求端需要限制: 对于同一个地址, 在几秒钟只能发送一次ARP(请求合并).

如果ARP<u>一直无响应</u>, 则源主机会发送 host unreachable 的**ICMP**给最初的请求发送者.

# 网络层
## 路由

路由器可以把一个IP报文从一个局域网转到另一个局域网, 也相当于对数据链路报文进行代理发送. 路由组件从一个网络接口接收IP报文, 然后决定在<u>某一个网络接口</u>上把报文内容再发出去.

**hop(跳)** 表示数据包通过一个网络节点(设备)(例如路由器)的一次转发动作. IP报文的**TTL（Time to Live）** 会限制总跳数, 每经过一个路由器的时候减1, 减完后变成0的话立即丢弃.

> [!note]
> TTL指示了<u>能抵达的网络的数量</u>. 例如初始TTL=2时, 只能:
> 1. 从主机抵达一个路由器;
> 2. 从路由器抵达目标.
> 
> 如果第2步还是找不到目标的话, 那么数据包在抵达下一个路由器的时候, 就会被丢弃.

路由匹配的依据是**路由表**. 路由表表示了`(路由前缀, 子网掩码) -> 下一跳地址`的映射. 如果目标地址与路由表的某一项的<u>子网掩码</u> <u>按位与</u> 之后, <u>与对应的路由前缀相等</u>, 则说明该目标地址*匹配这一个子网*; 选择**最长的匹配项**作为结果下一跳地址(longest-prefix-match). 

如果路由表匹配到项的下一跳地址为空, 表示目标主机就在该子网里面, 则下一跳地址直接设为目标主机的IP.

> [!note]
> 要求网络接口(数据链路层)发送IP数据报的时候, 需要给出`(数据报内容, 目标IP地址)`, 其中目标IP地址要么是<u>下一个目标服务器</u>, 要么就直接是<u>目标主机</u>.

路由表的更新可以通过手动指定, 也可以动态获取, 例如**RIP(Routing Information Protocol)**:
- *类型*：距离向量协议。
- *工作原理*：定期广播完整路由表，以跳数（最大15）为度量。
- *示例*：路由器A告诉邻居：“到达网络X需2跳”。
- *缺点*：收敛慢，仅适用于小型网络。


# TCP

TCP报文格式:
![](assets/Pasted%20image%2020250302222637.png)

TCP的 **序列号(sequence numbers, seqnos)** 使用32位(循环), 一个byte一个序列号; SYN和FIN都各占用一个序列号. 刚开始的序列号是使用 Initial Sequence Number (ISN) <u>随机初始化</u>的, 它也即是SYN的序列号. 一个TCP链接有两个方向的两个流, 各自有<u>独立</u>的seqnos和ISN. 
- **绝对序列号(absolute seqno)** 指从零开始的无循环的序列号.
- **流索引(stream indices)** 指不考虑SYN和FIN的 absolute seqno, 只考虑字节.

由于窗口最大大小不超过序列号的32位的中间点, 因此循环序列号不会出现歧义 (比大小方面不会出现歧义) (可以随着报文的接收不断更新一个绝对序列号参考值, 即可将其还原为绝对序列号).

ACK标志位指示确认号是否合法. 因此, 可以在**完全没有Receiver**的情况下发送报文, 只要声明<u>ACK非法</u>即可. 相反, <u>序列号必需合法</u>, 因此**Sender要有创建空内容报文**的功能.


## Sender & Receiver

TCP有两个方向, 各有一对Sender和Receiver.
- **Sender:
    - 负责发送**应用层数据**（如HTTP请求、文件内容等）。
    - 需要处理**序列号（SEQ）**、重传、拥塞控制（`cwnd`）和流量控制（`rwnd`）。
- **Receiver:
    - 负责接收对端发来的数据，并生成**ACK确认报文**。
    - 需要管理**接收窗口**、乱序重组和校验数据完整性。

> [!info]
>  outstanding segments 指 发出去但未确认的段.

TCP Receiver 第一次接收到带SYN的报文后, 就会以此序列号作为该流的ISN. 

TCP Receiver 只会接收窗口范围内的数据, 确认了才会接着移动窗口. 使用ACK+窗口大小即可确定**窗口范围**. **窗口大小**取决于其与<u>应用程序</u>间的<u>缓冲区剩余空间大小</u>, 如果应用程序消耗数据缓慢的话, 窗口大小会缩减.

> [!note]
> 由于SYN和FIN会占用序列号, 因此它们也就会占用窗口.

TCP Sender 从其与应用程序间的缓冲区中读取数据. 只要能发数据(存在待发送数据且<u>窗口未满</u>)就接着发. 刚开始的时候就假设对方Receiver的窗口大小为1.

> [!info]
> "窗口的使用量"被定义为"outstanding segments 的大小". 当**窗口已满**时, 相当于可以发的数据都发了, 但还没收到ACK; 于是此时<u>不能发送新数据</u>, 在收到新ACK之前都只能依据ARQ机制再重新发送outstanding segments.

TCP Sender 对 *占有了序列号的* outstanding segments 进行追踪, 从而超时重传, 即 **automatic repeat request (ARQ)**. 
- 使用**retransmission timeout (RTO)** 变量作为超时重传的时间, 且其<u>初值</u>在TCP创建时就<u>固定</u>下来了.
- 当且仅当有outstanding segments时, 才会计时.
- 超时后, 从最早的outstanding segments开始进行发送, 并且在*窗口大小非0*的情况下启动<u>指数退避(exponential backoff), 将RTO翻倍</u>, 然后重新计时.
- 接收到对<u>新数据的ACK</u>后, **重置**RTO为其初值, 若还有outstanding segments的话就重新计时.
- 可以统计在接收到ACK之前连续的重传包次数, 触发一定次数后即可认为连接情况过差, 可以断开连接.

> [!note]
> 刚开始假设对方Receiver的窗口大小为1, 使得最初的SYN丢包时, 也能触发RTO.

由于Receiver的<u>窗口大小信息</u>仅在接收到数据后才能对外发送, 因此*Sender*为了**及时更新窗口大小**, 可以在窗口大小为0的时候, <u>假装其是1</u>, 就可以发送非常小的"检测报文"去尝试更新窗口大小.

每次发送的数据量由以下因素共同决定：
- **发送窗口（Send Window）**：取接收方可用窗口（Advertised Window）和拥塞窗口（Congestion Window）的较小值。
- **MSS（Maximum Segment Size）**：单个TCP报文段的最大数据量（通常由MTU决定，如以太网中为1460字节）。
优先发送满MSS的数据段. 剩下的小数据就要考虑<u>糊涂窗口综合征</u>.

**糊涂窗口综合征（Silly Window Syndrome, SWS）** 发生于过小的窗口或过小的可用数据:
- **接收方SWS**：接收方处理数据缓慢，每次仅腾出极小窗口（如1字节），导致发送方只能发送小段。
	- *解决方案*: 在窗口太小的时候告知窗口大小为0.
- **发送方SWS**：发送方应用频繁生成小数据（如逐字节写入），未合并直接发送。
	- *解决方案*: **Nagle算法**：合并小数据段，只有在 已收到之前所有数据的ACK **或** 累积数据达到MSS 时才会发送：

在同一端中, Receiver的回复和Sender的响应可以合为一个报文一起发送, 称做**捎带(piggybacking)**.

## 粘包拆包

TCP本身是面向字节流的, 没有包概念. 因此应用层分别发送的"包"可能被合并或拆分.

- 粘包: 过小的多个包可能被合并起来一起发送.
- 拆包: 包过大, 被分成多次发送.

因此, 需要在上层手动指定包格式, 例如增加头部元数据或尾部分隔符, 或使用使用固定长度数据包, 从而在<u>假设随机分批到达的流</u>当中取出各个包.


## 三次握手 TODO



## 传递TCP包的几种方式


- TCP in UDP in IP: 使用**UDPSocket**, 只要提供了数据(payload), 就能自动生成UDP, IP和以太网的头. 在这payload中放入TCP报文即可.
- TCP in IP: 普通的TCP/IP形式. 使用**TUN设备**, 它允许应用程序提供完整的因特网报文, 然后自动生成以太网头; 可以认为是交换<u>IP报文</u>的接口. 这就要求应用程序自己负责IP头的生成.
- TCP in IP in Ethernet: 使用**TAP设备**, 是交换<u>以太网报文</u>的接口. 这就要求应用程序自己负责以太网头.


