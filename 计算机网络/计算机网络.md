



# 层

OSI 模型 和 TCP/IP模型 **对应关系**:
  - OSI 应用层 ≈ TCP/IP 应用层（含会话层、表示层功能）  
  - OSI 传输层 ≈ TCP/IP 传输层  
  - OSI 网络层 ≈ TCP/IP 网络层  
  - OSI 数据链路层+物理层 ≈ TCP/IP 网络接口层

在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。
## OSI

OSI（开放系统互联）模型 七层结构:

1. **物理层（Physical Layer）**
	- *功能*：传输原始比特流，定义物理介质（电缆、光纤、无线频率）的电气、机械特性。  
	- *技术/协议*：  
	  - 物理介质：双绞线（Cat5/6）、光纤、Wi-Fi（802.11射频）  
	  - 编码技术：曼彻斯特编码、QAM调制  
	  - 设备：中继器（Repeater）、集线器（Hub）
2. **数据链路层（Data Link Layer）**
	- *功能*：在直接相连的设备间传输数据帧，通过MAC地址寻址，实现可靠的点对点通信。  
	- *技术/协议*：  
	  - 以太网（Ethernet, IEEE 802.3）  
	  - MAC地址（如 `00:1A:2B:3C:4D:5E`）  
	  - ARP（地址解析协议）、VLAN（虚拟局域网）  
	  - 设备：交换机（Switch）、网桥（Bridge）
3. **网络层（Network Layer）**
	- *功能*：跨网络路由数据包，选择最佳路径，实现逻辑寻址（IP地址）。  
	- *技术/协议*：  
	  - IP协议（IPv4/IPv6）  
	  - 路由协议：RIP、OSPF、BGP  
	  - ICMP（用于网络诊断，如 `ping`）  
	  - 设备：路由器（Router）
4. **传输层（Transport Layer）**
	- *功能*：提供端到端（进程到进程）的可靠或不可靠数据传输，管理流量控制、错误恢复。  
	- *技术/协议*：  
	  - TCP（可靠传输，三次握手，如网页、文件传输）  
	  - UDP（不可靠传输，低延迟，如视频流、DNS查询）  
	  - 端口号（如 HTTP-80、HTTPS-443）
5. **会话层（Session Layer）**
	- *功能*：建立、管理、终止应用程序之间的会话（连接），同步数据交换。  
	- *技术/协议*：  
	  - NetBIOS（局域网会话管理）  
	  - RPC（远程过程调用）  
	  - SIP（VoIP会话控制）
6. **表示层（Presentation Layer）**
	- *功能*：数据格式转换（编码、加密、压缩），确保不同系统间的数据兼容性。  
	- *技术/协议*：  
	  - SSL/TLS（加密/解密）  
	  - JPEG/MPEG（图像/视频编码）  
	  - ASCII/Unicode（字符编码）
7. **应用层（Application Layer）**
	- *功能*：为应用程序提供网络服务接口，直接面向用户。  
	- *技术/协议*：  
	  - HTTP（网页访问）  
	  - FTP（文件传输）  
	  - SMTP/POP3（电子邮件）  
	  - DNS（域名解析）  
	  - SSH（安全远程登录）


## TCP/IP

1. **网络接口层 (Network Interface Layer)**
	- *功能*：负责在物理网络上发送和接收数据帧，处理物理地址（如MAC地址）。
	- *技术名*：以太网（Ethernet）、Wi-Fi（IEEE 802.11）、PPP（点对点协议）、ARP（地址解析协议）等。
2. **网络层 (Internet Layer)**
	- *功能*：负责数据包的路由选择和转发，处理逻辑地址（如IP地址）。
	- *技术名*：IP（互联网协议，包括IPv4和IPv6）、ICMP（互联网控制消息协议）、IGMP（互联网组管理协议）等。
3. **传输层 (Transport Layer)**
	- *功能*：提供端到端的通信，确保数据的完整性和顺序，处理流量控制和错误恢复。
	- *技术名*：TCP（传输控制协议）、UDP（用户数据报协议）、SCTP（流控制传输协议）等。
4. **应用层 (Application Layer)**
	- *功能*：为用户提供网络服务，直接与用户交互，处理应用程序之间的通信。
	- *技术名*：HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名系统）、Telnet等。



# 数据链路层

数据链路层负责建立单跳传输网络(没有路由).

## 报文

数据链路层地址就是MAC.

以太网(Ethernet)帧:
![](assets/Pasted%20image%2020250304234638.png)

其中的以太网头部即是**MAC头部**(14字节):
![](assets/Pasted%20image%2020250306000042.png)

MAC广播地址是`ff:ff:ff:ff:ff:ff`.

一般TCP/IP中, 协议类型只使用:
- `0800`: IP 协议
- `0806`: ARP 协议

以太网帧会被网卡再度包装, 包括添加校验.

## ARP Address Resolution Protocol

1. 为了访问目标IP的主机, 就要当知道其对应的MAC地址.
2. 当本地ARP缓存没有目标时, 使用ARP进行广播查询. 广播范围是<u>本地网络</u>, 且只有符合目标IP的主机才会应答(其他主机都丢弃). 
3. 应答主机也会记录源主机的ARP信息(MAC-IP)(其他主机不缓存).
4. 应答主机返回其ARP信息.
5. 源主机收到ARP回复, 更新信息. 信息有生存期, 会过期.

ARP报文被放在以太网的payload当中(就像IP报文被放在里面一样), 然后设置以太网报文首部的类型部分为ARP标记.

ARP报文(28 字节):
![](assets/Pasted%20image%2020250304231945.png)

> [!note]
> 在TCP/IP中, ARP属于"网络接口层".

> [!note]
> 可见网络接口需要支持:
> 1. <u>指定IP地址</u>(可能是目标主机, 也可能是下一跳路由器), 发送IP数据包, 如果不知道目标MAC地址则转而发送ARP.
> 2. 接收IP数据包.
> 3. 接收ARP响应, 以更新ARP缓存, 并及时发送相关的等待队列中的请求.
> 4. 接收ARP请求, 在更新ARP缓存的同时进行自己的ARP信息的响应.

> [!info]
> 网络接口根据 数据包的<u>目标MAC</u>部分 , 当其<u>同时满足</u>下面的条件时, 直接**丢弃**数据包:
> 1. 非广播(广播用于ARP请求).
> 2. 非自己.

为了防止ARP泛滥, 一个请求端需要限制: 对于同一个地址, 在几秒钟只能发送一次ARP(请求合并).

如果ARP<u>一直无响应</u>, 则源主机会发送 host unreachable 的**ICMP**给最初的请求发送者.

## 交换机

可以连接多条网线. 内部存储`MAC->端口`映射, 如果没有匹配的就把包广播发送, 并对表进行更新.

交换机没有MAC地址.

# 网络层

## IP

IPv4报文(头部基础20字节):
![](assets/Pasted%20image%2020250305230513.png)

> [!info]
> TCP的协议号是`06H`.

> [!note]
> 虽然数据链路层有校验, 但是它只负责一跳内的数据传输校验, 但无法检测中间设备(路由器)带来的内容改变.
## IP地址

`10.100.122.2/24`:
- IP地址: `10.100.122.2`
- 子网掩码: `24` $\rightarrow$ `255.255.255.0`
- 网络号: `10.100.122.0` (子网掩码取反后 和 IP地址 按位与)
- 主机号: `2` (剩下的号)

主机号全0表示网络本身, 全1表示广播.


## 路由

路由器可以把一个IP报文从一个局域网转到另一个局域网, 也相当于对数据链路报文进行代理发送. 路由组件从一个网络接口接收IP报文, 然后决定在<u>某一个网络接口</u>上把报文内容再发出去; MAC报文会被重新生成.

路由器的各个端口都有MAC和IP地址.

**hop(跳)** 表示数据包通过一个网络节点(设备)(例如路由器)的一次转发动作. IP报文的**TTL（Time to Live）** 会限制总跳数, 每经过一个路由器的时候减1, 减完后变成0的话立即丢弃.

> [!note]
> TTL指示了<u>能抵达的网络的数量</u>. 例如初始TTL=2时, 只能:
> 1. 从主机抵达一个路由器;
> 2. 从路由器抵达目标.
> 
> 如果第2步还是找不到目标的话, 那么数据包在抵达下一个路由器的时候, 就会被丢弃.

路由匹配的依据是**路由表**. 路由表表示了`(路由前缀, 子网掩码) -> (下一跳地址, 路由器接口)`的映射. 如果目标地址与路由表的某一项的<u>子网掩码</u> <u>按位与</u> 之后, <u>与对应的路由前缀相等</u>, 则说明该目标地址*匹配这一个子网*; 选择**最长的匹配项**作为结果(longest-prefix-match); 都匹配不到时, 就把目标设为指定的默认网关(也对应了一个路由表条目, 其下一跳地址是`0.0.0.0`).

如果路由表匹配到项的下一跳地址为空, 表示目标主机就在该子网里面(或者说该子网是该路由器的直连子网), 则下一跳地址直接设为目标主机的IP.

> [!note]
> 要求网络接口(数据链路层)发送IP数据报的时候, 需要给出`(数据报内容, 目标IP地址)`, 其中目标IP地址要么是<u>下一个目标服务器</u>, 要么就直接是<u>目标主机</u>.

路由表的更新可以通过手动指定, 也可以动态获取, 例如**RIP(Routing Information Protocol)**:
- *类型*：距离向量协议。
- *工作原理*：定期广播完整路由表，以跳数（最大15）为度量。
- *示例*：路由器A告诉邻居：“到达网络X需2跳”。
- *缺点*：收敛慢，仅适用于小型网络。

> [!note]
> 路由使得网络被分为多个块. 由于跨块通信需要通过路由来处理, 因此可以把网络抽象为图, 使用算法来优化网络(通过修改路由表).

> [!note]
> 除了网络传输优化, 路由还提供了 NAT, 防火墙过滤, 限制广播范围 等特殊功能.

## ICMP

1. 网络连通性测试: 通过 `ping` 命令发送 **ICMP Echo Request（类型8）**，目标设备回复 **ICMP Echo Reply（类型0）**，验证两台设备是否可达。
2. 错误报告: 当数据包无法到达目标时，路由器或主机会生成 **ICMP错误报文**，例如：
	- **目标不可达（类型3）**：网络不可达（代码0）、主机不可达（代码1）、端口不可达（代码3）等。
	- **超时（类型11）**：TTL减至0时触发（如 `traceroute` 探测路径）。
3. 网络优化:
	- **重定向（类型5）**：路由器通知发送方存在更优路径。
	- **路径MTU发现**：通过ICMP报文确定链路中最大传输单元（MTU），避免IP分片。

ICMP报文放在IP数据包的payload中（IP头协议字段值为1），其报文: 
- **基础大小**：8 字节
- 类型（1字节）、代码（1字节）、校验和（2字节）
- 可变字段（如 `Echo Request/Reply` 中的标识符和序列号）：4 字节
- **附加数据**：可能携带原始错误数据包的 IP 头 + 前 8 字节负载。


# 传输层


## UDP

![](assets/Pasted%20image%2020250306221431.png)


## TCP

TCP报文格式(头部基础大小20字节):
![](assets/Pasted%20image%2020250305225032.png)

TCP的 **序列号(sequence numbers, seqnos)** 使用32位(循环), 一个byte一个序列号; SYN和FIN都各占用一个序列号. 刚开始的序列号是使用 **Initial Sequence Number (ISN)** <u>随机初始化</u>的, 它也即是SYN的序列号. 一个TCP链接有两个方向的两个流, 各自有<u>独立</u>的seqnos和ISN. 
- **绝对序列号(absolute seqno)** 指从零开始的无循环的序列号.
- **流索引(stream indices)** 指不考虑SYN和FIN的 absolute seqno, 只考虑字节.

由于窗口最大大小不超过序列号的32位的中间点, 因此循环序列号不会出现歧义 (比大小方面不会出现歧义) (可以随着报文的接收不断更新一个绝对序列号参考值, 即可将其还原为绝对序列号).

ACK标志位指示确认号是否合法. 因此, 可以在**完全没有Receiver**的情况下发送报文, 只要声明<u>ACK非法</u>即可. 相反, <u>序列号必需合法</u>, 因此**Sender要有创建空内容报文**的功能.


### Sender & Receiver

TCP有两个方向, 各有一对Sender和Receiver.
- **Sender:
    - 负责发送**应用层数据**（如HTTP请求、文件内容等）。
    - 需要处理**序列号（SEQ）**、重传、拥塞控制（`cwnd`）和流量控制（`rwnd`）。
- **Receiver:
    - 负责接收对端发来的数据，并生成**ACK确认报文**。
    - 需要管理**接收窗口**、乱序重组和校验数据完整性。

> [!info]
>  outstanding segments 指 发出去但未确认的段.

---

TCP Receiver 第一次接收到带SYN的报文后, 就会以此序列号作为该流的ISN. 

TCP Receiver 只会接收窗口范围内的数据, 确认了才会接着移动窗口. 使用ACK+窗口大小即可确定**窗口范围**. **窗口大小**取决于其与<u>应用程序</u>间的<u>缓冲区剩余空间大小</u>, 如果应用程序消耗数据缓慢的话, 窗口大小会缩减.

> [!note]
> 由于SYN和FIN会占用序列号, 因此它们也就会占用窗口.

**ACK的数值**即是SYN+已确认的数据量, 因此ACK的语义是"<u>需要的下一个序列号</u>".

---

TCP Sender 从其与应用程序间的缓冲区中读取数据. 只要能发数据(存在待发送数据且<u>窗口未满</u>)就接着发. 刚开始的时候就假设对方Receiver的窗口大小为1.

> [!info]
> "窗口的使用量"被定义为"outstanding segments 的大小". 当**窗口已满**时, 相当于可以发的数据都发了, 但还没收到ACK; 于是此时<u>不能发送新数据</u>, 在收到新ACK之前都只能依据ARQ机制再重新发送outstanding segments.

TCP Sender 对 *占有了序列号的* outstanding segments 进行追踪, 从而超时重传, 即 **automatic repeat request (ARQ)**. 
- 使用**retransmission timeout (RTO)** 变量作为超时重传的时间, 且其<u>初值</u>在TCP创建时就<u>固定</u>下来了.
- 当且仅当有outstanding segments时, 才会计时.
- 超时后, 从最早的outstanding segments开始进行发送, 并且在*窗口大小非0*的情况下启动<u>指数退避(exponential backoff), 将RTO翻倍</u>, 然后重新计时.
- 接收到对<u>新数据的ACK</u>后, **重置**RTO为其初值, 若还有outstanding segments的话就重新计时.
- 可以统计在接收到ACK之前连续的重传包次数, 触发一定次数后即可认为连接情况过差, 可以断开连接.

> [!note]
> 刚开始假设对方Receiver的窗口大小为1, 使得最初的SYN丢包时, 也能触发RTO.

由于Receiver的<u>窗口大小信息</u>仅在接收到数据后才能对外发送, 因此*Sender*为了**及时更新窗口大小**, 可以在窗口大小为0的时候, <u>假装其是1</u>, 就可以发送非常小的"检测报文"去尝试更新窗口大小.

每次发送的数据量由以下因素共同决定：
- **发送窗口（Send Window）**：取接收方可用窗口（Advertised Window）和拥塞窗口（Congestion Window）的较小值。
- **MSS（Maximum Segment Size）**：单个TCP报文段的数据最大尺寸. MTU是一个网络包的最大长度, 在以太网中一般是1500字节; 去掉头部长度就是MSS.
优先发送满MSS的数据段. 剩下的小数据就要考虑<u>糊涂窗口综合征</u>.

---

**糊涂窗口综合征（Silly Window Syndrome, SWS）** 发生于过小的窗口或过小的可用数据:
- **接收方SWS**：接收方处理数据缓慢，每次仅腾出极小窗口（如1字节），导致发送方只能发送小段。
	- *解决方案*: 在窗口太小的时候告知窗口大小为0.
- **发送方SWS**：发送方应用频繁生成小数据（如逐字节写入），未合并直接发送。
	- *解决方案*: **Nagle算法**：合并小数据段，只有在 已收到之前所有数据的ACK **或** 累积数据达到MSS 时才会发送：

在同一端中, Receiver的回复和Sender的响应可以合为一个报文一起发送, 称做**捎带(piggybacking)**.

### 粘包拆包

TCP本身是面向字节流的, 没有包概念. 因此应用层分别发送的"包"可能被合并或拆分.

- 粘包: 过小的多个包可能被合并起来一起发送.
- 拆包: 包过大, 被分成多次发送.

因此, 需要在上层手动指定包格式, 例如增加头部元数据或尾部分隔符, 或使用使用固定长度数据包, 从而在<u>假设随机分批到达的流</u>当中取出各个包.

### 传递TCP包的几种方式


- TCP in UDP in IP: 使用**UDPSocket**, 只要提供了数据(payload), 就能自动生成UDP, IP和以太网的头. 在这payload中放入TCP报文即可.
- TCP in IP: 普通的TCP/IP形式. 使用**TUN设备**, 它允许应用程序提供完整的因特网报文, 然后自动生成以太网头; 可以认为是交换<u>IP报文</u>的接口. 这就要求应用程序自己负责IP头的生成.
- TCP in IP in Ethernet: 使用**TAP设备**, 是交换<u>以太网报文</u>的接口. 这就要求应用程序自己负责以太网头.

### 三次握手

![](assets/Pasted%20image%2020250305230959.png)

1. 一开始均为`CLOSE`.
2. 服务端监听端口, 即是`LISTEN`.
3. 客户端发出SYN后, 变成`SYN-SENT`.
4. 服务端接收到SYN, 于是返回ACK+自己的SYN, 并变成`SYN-RCVD`.
5. 客户端接收到SYN+ACK后, 返回对此SYN的ACK, 并变成`ESTABLISHED`.
6. 服务端接收到进一步的ACK后, 也变成`ESTABLISHED`.

**最后一次ACK是必要的**, 因为有可能客户端发送过一次SYN但过了好久终于被服务端收到, 但此时客户端已经没有继续使用这个SYN了, 这个时候会返回RST, 使得服务端放弃这个连接.


### 四次挥手

只不过是把三次握手的SYN换成FIN. 而且第二步的<u>FIN和ACK可以分开也可以合一</u>, 即可以缩成三次挥手. 允许分成四次的原因是: 允许一方关闭后另一方继续发数据.

![](assets/Pasted%20image%2020250306221831.png)

- 客户端计算相关连接，此时会发送一个 TCP 首部，FIN 标志位被设置为 1 的报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务器端收到该报文后，就向客户端发送 ACK 应答报文，接着客户端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务器端的 ACK 应答后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务器端处理完数据后，也向客户端发送 FIN 报文，之后服务器端进入 `LAST_ACK` 状态。
- 客户端收到服务器端的 FIN 报文后，回一个 ACK 应答报文，之后进入 `TIME_WAIT` 状态。
- 服务器端收到 ACK 应答后，就进入 `CLOSE` 状态，此时服务器端已经完成连接的关闭。
- 客户端在经过 2MSL（最大报文生存时间）的一段时间后，自动进入 `CLOSE` 状态，此时客户端也完成连接的关闭。

## 拥塞控制 TODO


# Http

超文本传输协议, HyperText Transfer Protocol.

- 1xx:提示信息，表示目前是协议处理的中间状态，还需要后续的操作：
- 2xx: 成功，报文已经收到并被正确处理；
- 3xx: 重定向，资源位置发生变化，需要客户端重新发送请求；
- 4xx: 客户端错误，请求报文有误，服务器无法处理；
- 5xx: 服务器错误，服务器在处理请求的内部发生了错误。

GET请求要求**幂等**.

HTTP/1.1 默认使用 `Connection: keep-alive` 复用 TCP 连接.

## 请求报文

1. **请求行（Request Line）**  
	- 格式：`方法 请求目标 HTTP版本`  
	- 示例：`GET /index.html HTTP/1.1`  
	- **方法**：定义操作类型（如 `GET`、`POST`、`PUT`、`DELETE`）。  
	- **请求目标**：通常是 URL 的路径（如 `/api/data`）。  
	- **HTTP 版本**：如 `HTTP/1.1` 或 `HTTP/2`。
2. **请求头（Headers）**  
	- 键值对格式，定义请求的元信息，例如：  
```http
 Host: www.example.com
 User-Agent: Mozilla/5.0
 Accept: text/html
 Content-Type: application/json
```
3. **空行**  
	- 表示头部的结束（通过 `\r\n` 分隔）。
4. **请求体（Body，可选）**  
	- 仅用于需要传输数据的请求（如 `POST`、`PUT`）。  

示例:
```http
POST /login HTTP/1.1
Host: www.example.com
User-Agent: Chrome/120
Content-Type: application/json
Content-Length: 36

{ "username": "user", "password": "pass" }
```

## 响应报文

1. **状态行（Status Line）**  
	- 格式：`HTTP版本 状态码 状态消息`  
	- 示例：`HTTP/1.1 200 OK`  
	- **状态码**：表示请求结果（如 `200` 成功，`404` 未找到，`500` 服务器错误）。 
	- **状态消息**：简短的文字描述（如 `OK`、`Not Found`）。
2. **响应头（Headers）**  
	- 定义响应的元信息，例如：  
```http
Server: Apache/2.4
Content-Type: text/html
Content-Length: 1024
Set-Cookie: session=abc123
```
3. **空行**  
	- 分隔头部和响应体。
4. **响应体（Body，可选）**  
	- 服务器返回的实际内容（如 HTML、JSON、图片等）。  

示例:
```http
HTTP/1.1 200 OK
Server: Nginx/1.18
Content-Type: text/html
Content-Length: 127

<html><h1>Success!</h1></html>
```


## https

https保护请求不被窃听(加密), 篡改(校验)和冒充(身份证书). 它在http和tcp之间(表示层)加了**SSL/TLS**协议. SSL/TLS（Secure Sockets Layer/Transport Layer Security）是保障网络通信安全的加密协议.

加密:
- 建立连接的时候, 使用**非对称加密**交换<u>会话密钥</u>.
- 使用基于<u>会话密钥</u>的**对称加密**进行交流.

校验: 每边都有一个私钥. 先生成哈希摘要, 然后使用自己的私钥对其进行数字签名(之后只传签名), 从而:
- 保证数据来自于持有<u>签名用私钥</u>的一方. (无法篡改签名)
- 保证数据内容未被篡改. (无法篡改签名, 也就无法篡改解出来的哈希摘要)
![](assets/Pasted%20image%2020250306211200.png)

> [!note]
> 没有"客户端伪装"一说, 因为这"假客户端"无法解析拦截到的任何数据, 也无法以中间人身份进行篡改.

如果一开始连接的就是假服务器的话, 就会使用假服务器的公钥来验证, 是无法识别其伪装的, 因此需要<u>第三方</u>权威记录合法的服务器, 记录方式是**声明其公钥合法**. 
- 服务器方提前向证书颁发机构(CA)登记, 获得证书.
- 服务器在收到请求时会返回<u>数字证书（包含公钥、域名、CA 签名等）</u>.
- 浏览器通过CA信息(事先放到了浏览器里面)检验证书合法性.

CA证书也是通过CA签名来生成, 使用CA公钥解密即可验证服务器发来的证书内容是否合法.
![](assets/Pasted%20image%2020250306215324.png)

> [!note]
> 证书合法 -> 公钥合法 -> 使用此公钥加密的数据只能被合法服务器解密

证书的合法性由[Certificate Transparency (CT)](MIT6.824%20Distributed%20Systems/课堂笔记.md#Certificate%20Transparency)保证.

> [!info]
> TLS 1.3 删除了不安全的算法（如 RSA 密钥交换），默认支持前向保密（Forward Secrecy），并将握手流程缩短为 1-RTT（单次往返）。

TLS 1.3 握手流程:
1. **Client Hello**
	- 客户端发送：
	- *支持的 TLS 版本*（仅 TLS 1.3）。
	- *支持的加密套件*（如 `TLS_AES_128_GCM_SHA256`）。
	- *客户端随机数*（Client Random）。
	- *密钥共享参数*（Key Share）：客户端生成临时 DH 公钥（如 ECDHE 参数），用于快速生成共享密钥。
2. **Server Hello**
	- 服务器响应：
	- *选择的加密套件*。
	- *服务器随机数*（Server Random）。
	- *服务器密钥共享参数*（Server Key Share）：服务器的临时 DH 公钥。
	- *数字证书*（可选发送证书，或在后续步骤中发送）。
3. **密钥生成与验证**
	- *生成共享密钥*：客户端和服务器通过 DH 参数计算共享密钥（无需传递 Pre-Master Secret）。
	- *派生会话密钥*：使用 HKDF（HMAC-based Key Derivation Function）从共享密钥生成会话密钥。
	- *证书验证*：客户端验证服务器证书（与 TLS 1.2 相同）。
4. **完成握手**
	- *客户端和服务器交换 "Finished" 消息*：验证握手完整性，确认密钥正确。
	- *握手完成*：开始加密通信。


# Linux 网络

![](assets/Pasted%20image%2020250306103959.png)

## 接收网络包

- 当网络包到达时, 会通过DMA将其写到一块内存处(是一个ring buffer).
- **NAPI**机制: 通过硬中断仅唤醒网络包读取程序(此时硬中断被暂时屏蔽), 然后使用软中断触发轮询式读取.

读到的网络数据(sk_buff)位于socket的缓冲区中; 之后, 用户通过系统调用读取数据.

sk_buff这一个结构体就能表示所有协议栈级别的数据包, 通过调整`skb->data`就能逐个剥离头部.

总共有两次拷贝:
1. DMA -> 内核内存 (无CPU参与)
2. 内核内存 -> 用户内存
第二个可以使用<u>零拷贝优化</u>来省略.

## 发送网络包

用户的系统调用(针对Socket)将数据放到内核中的sk_buff内存中, 并将其加入到发送缓冲区. 要发送的时候, 网络协议栈再读取sk_buff.

通过调整`skb->data`就能不断在sk_buff中加上头部, 最终形成完整数据包.

使用软中断通知网卡驱动程序, 将数据包放入ring buffer中, 然后DMA将其发送.

> [!note]
> TCP为了支持重传, 会拷贝一次sk_buff进行发送; 收到ACK时, 才会删除对应的sk_buff.














