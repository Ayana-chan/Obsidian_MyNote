
# 杂项知识点

如果使用IFDEF，可能导致某个函数在某个条件下被认为定义后从未被使用，从而出现warning被视为error。因此被IFDEF套住的极少使用的函数都应该设为inline。

使用宏而非inline的一大好处是可以访问上下文的变量，而无须关心“栈逻辑”。

`__VA_ARGS__`是内置的宏，可以被替换为可变参数中的`...`。可以做到把可变的那部分参数给传到另一个可变参数的函数中去。其一大能力就是让宏定义中的可变参数可以是一个语句块，被放到`__VA_ARGS__`所在的地方执行。

`#define concat_temp(x, y) x ## y`可以把x、y合成xy返回。

使用`#xxx`即可将宏接收的几个裸字符转化为字符串。

宏中的注释只能是`/* abc */`这种格式，否则无法换行。
# pa0

init之后`~/.bashrc`会自动添加（如果不从零开始的话可能得手动添加）：

```bash
export NEMU_HOME=/home/ayana/workspace/ics2023/nemu                         
export AM_HOME=/home/ayana/workspace/ics2023/abstract-machine
```

`make menuconfig`报错时执行：

```bash
sudo apt-get install bison
sudo apt-get install flex
```


# pa1

配置ccache的时候，只需在`~/.bashrc`加入：

```bash
#让ccache的软链接被提到PATH的最高优先级
export PATH="/usr/lib/ccache:$PATH" 
```

配置时会生成的重要文件包括：
- `nemu/include/generated/autoconf.h`, 阅读C代码时使用
- `nemu/include/config/auto.conf`, 阅读Makefile时使用

`$(CFLAGS)`值如下，是gcc编译的参数：

```bash
-O2 -MMD -Wall -Werror -I/home/user/ics2023/nemu/include
-I/home/user/ics2023/nemu/src/engine/interpreter -I/home/use
r/ics2023/nemu/src/isa/riscv32/include -O2    -D__GUEST_ISA__
=riscv32
```

>我们知道内存是一种RAM, 是一种易失性的存储介质, 这意味着计算机刚启动的时候, 内存中的数据都是无意义的; 而BIOS是固化在ROM/Flash中的, 它们都是非易失性的存储介质, BIOS中的内容不会因为断电而丢失.
 因此在真实的计算机系统中, 计算机启动后首先会把控制权交给BIOS, BIOS经过一系列初始化工作之后, 再从磁盘中将有意义的程序读入内存中执行. 对这个过程的模拟需要了解很多超出本课程范围的细节, 我们在PA中做了简化: 采取约定的方式让CPU直接从约定的内存位置开始执行.

>x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样, 例如mips32和riscv32的物理地址均从`0x80000000`开始. 因此对于mips32和riscv32, 其`CONFIG_MBASE`将会被定义成`0x80000000`. 将来CPU访问内存时, 我们会将CPU将要访问的内存地址映射到`pmem`中的相应偏移位置, 这是通过`nemu/src/memory/paddr.c`中的`guest_to_host()`函数实现的. 例如如果mips32的CPU打算访问内存地址`0x80000000`, 我们会让它最终访问`pmem[0]`, 从而可以正确访问客户程序的第一条指令. 这种机制有一个专门的名字, 叫地址映射, 在后续的PA中我们还会再遇到它.

## RTFSC

`init_monitor`：

```c
101 void init_monitor(int argc, char *argv[]) {
102   /* Perform some global initialization. */
103 
104   /* Parse arguments. */
105   parse_args(argc, argv);
106 
107   /* Set random seed. */
108   init_rand();
109 
110   /* Open the log file. */
111   init_log(log_file);
112 
113   /* Initialize memory. */
114   init_mem();
115 
116   /* Initialize devices. */
117   IFDEF(CONFIG_DEVICE, init_device());
118 
119   /* Perform ISA dependent initialization. */
120   init_isa();
121 
122   /* Load the image to memory. This will overwrite the built-in image. */
123   long img_size = load_img();
124 
125   /* Initialize differential testing. */
126   init_difftest(diff_so_file, img_size, difftest_port);
127 
128   /* Initialize the simple debugger. */
129   init_sdb();
130 
131 #ifndef CONFIG_ISA_loongarch32r
132   IFDEF(CONFIG_ITRACE, init_disasm(
133     MUXDEF(CONFIG_ISA_x86,     "i686",
134     MUXDEF(CONFIG_ISA_mips32,  "mipsel",
135     MUXDEF(CONFIG_ISA_riscv,
136       MUXDEF(CONFIG_RV64,      "riscv64",
137                                "riscv32"),
138                                "bad"))) "-pc-linux-gnu"
139   ));
140   #endif
141 
142   /* Display welcome message. */
143   welcome();
144 }
```

`load_img()`函数 (在`nemu/src/monitor/monitor.c`中定义)会将一个有意义的客户程序从[镜像文件](https://en.wikipedia.org/wiki/Disk_image)读入到内存, 覆盖刚才的内置客户程序. 这个镜像文件是运行NEMU的一个可选参数, 在运行NEMU的命令中指定. 如果运行NEMU的时候没有给出这个参数, NEMU将会运行内置客户程序.

Monitor的初始化工作结束后, `main()`函数会继续调用`engine_start()`函数 (在`nemu/src/engine/interpreter/init.c`中定义). 代码会进入简易调试器(Simple Debugger)的主循环`sdb_mainloop()` (在`nemu/src/monitor/sdb/sdb.c`中定义)。

`strtok(str, " ")`使用空格将str字符串分为多个部分，若无结果则返回NULL，否则返回分割后的第一个字符串。之后，str会被存入静态缓冲区，下次要其他被分割字符时直接调用`strtok(NULL, " ")`。

debug函数：

- `Log()`是`printf()`的升级版, 专门用来输出调试信息, 同时还会输出使用`Log()`所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置。`Log("Can not find sdcard image: %s", img);`
- `Assert()`是`assert()`的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息。`Assert(fp, "Can not open '%s'", img_file);`
- `panic()`用于输出信息并结束程序, 相当于无条件的assertion fail。`panic("unhandle offset = %d", offset);`

```c
 23 #define Log(format, ...) \
 24     _Log(ANSI_FMT("[%s:%d %s] " format, ANSI_FG_BLUE) "\n", \
 25         __FILE__, __LINE__, __func__, ## __VA_ARGS__)
 26 
 27 #define Assert(cond, format, ...) \
 28   do { \
 29     if (!(cond)) { \
 30       MUXDEF(CONFIG_TARGET_AM, printf(ANSI_FMT(format, ANSI_FG_RED) "\n", ## __VA_ARGS__), \
 31         (fflush(stdout), fprintf(stderr, ANSI_FMT(format, ANSI_FG_RED) "\n", ##  __VA_ARGS__))); \
 32       IFNDEF(CONFIG_TARGET_AM, extern FILE* log_fp; fflush(log_fp)); \
 33       extern void assert_fail_msg(); \
 34       assert_fail_msg(); \
 35       assert(cond); \
 36     } \
 37   } while (0)
 38 
 39 #define panic(format, ...) Assert(0, format, ## __VA_ARGS__)
 40 
 41 #define TODO() panic("please implement me")
```

>## __VA_ARGS__ 是宏定义中的可变参数部分。在宏定义中，__VA_ARGS__ 表示一个可变参数的占位符。## 是一个预处理器操作符，用于在宏展开时处理可变参数。  
  ## 的作用是将可变参数与前面的标识符（在这个例子中是 format）连接起来，以便在宏展开时形成一个完整的参数列表。这样可以使得宏在接受可变数量的参数时更加灵活。  

q时返回Error1的原因：main会调用src/utils/state.c:int is_exit_status_bad()，里面要求nemu_state.state要妥善处理，此时应当处理为NEMU_QUIT ：

```c
 20 int is_exit_status_bad() {
 21   int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) 
 22   || (nemu_state.state == NEMU_QUIT);              
 23   return !good;
 24 }
```

## 基础设施

|命令|格式|使用举例|说明|
|---|---|---|---|
|帮助(1)|`help`|`help`|打印命令的帮助信息|
|继续运行(1)|`c`|`c`|继续运行被暂停的程序|
|退出(1)|`q`|`q`|退出NEMU|
|单步执行|`si [N]`|`si 10`|让程序单步执行`N`条指令后暂停执行,  <br>当`N`没有给出时, 缺省为`1`|
|打印程序状态|`info SUBCMD`|`info r`  <br>`info w`|打印寄存器状态  <br>打印监视点信息|
|扫描内存(2)|`x N EXPR`|`x 10 $esp`|求出表达式`EXPR`的值, 将结果作为起始内存  <br>地址, 以十六进制形式输出连续的`N`个4字节|
|表达式求值|`p EXPR`|`p $eax + 1`|求出表达式`EXPR`的值, `EXPR`支持的  <br>运算请见[调试中的表达式求值](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/1.6.html)小节|
|设置监视点|`w EXPR`|`w *0x2000`|当表达式`EXPR`的值发生变化时, 暂停程序执行|
|删除监视点|`d N`|`d 2`|删除序号为`N`的监视点|


单步执行步数太大会导致无法输出状态。打印状态的函数是`static void trace_and_difftest(Decode *_this, vaddr_t dnpc)`。`trace_and_difftest`会调用`log_write`，而write前会先判断`log_enable`。启动时的`log_init`也会指定输出路径，默认显示`[src/utils/log.c:28 init_log] Log is written to /home/ayana/workspace/ics2023/nemu/build/nemu-log.txt`。

```
(nemu) si 1
0x80000000: 00 00 02 97 auipc	t0, 0
(nemu) si 1
0x80000004: 00 02 88 23 sb	zero, 16(t0)
(nemu) si 1
0x80000008: 01 02 c5 03 lbu	a0, 16(t0)
(nemu) si 1
0x8000000c: 00 10 00 73 ebreak	
[src/cpu/cpu-exec.c:123 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000000c
[src/cpu/cpu-exec.c:88 statistic] host time spent = 303 us
[src/cpu/cpu-exec.c:89 statistic] total guest instructions = 4
[src/cpu/cpu-exec.c:90 statistic] simulation frequency = 13,201 inst/s
(nemu) q
```


```c
//src/utils/log.c
 18 extern uint64_t g_nr_guest_inst; //位于src/cpu/cpu_exec.c，执行一步就加一
 19 FILE *log_fp = NULL;
 20 
 21 void init_log(const char *log_file) {
 22   log_fp = stdout;
 23   if (log_file != NULL) {
 24     FILE *fp = fopen(log_file, "w");
 25     Assert(fp, "Can not open '%s'", log_file);
 26     log_fp = fp;
 27   }
 28   Log("Log is written to %s", log_file ? log_file : "stdout");
 29 }
 30 
 31 bool log_enable() {
 32   return MUXDEF(CONFIG_TRACE, (g_nr_guest_inst >= CONFIG_TRACE_START) &&
 33          (g_nr_guest_inst <= CONFIG_TRACE_END), false);
 34 }  
```

封装好的整数类型：

```c
include/common.h:typedef MUXDEF(CONFIG_ISA64, uint64_t, uint32_t) word_t;
include/common.h:typedef MUXDEF(CONFIG_ISA64, int64_t, int32_t)  sword_t;
```

cpu定义如下：

```c
 21 typedef struct {
 22   word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; //寄存器
 23   vaddr_t pc; //Program Counter寄存器
 24 } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);
```

四个字节刚好八位16进制，如0x80000000。

内存的读写逻辑如下，实际上，高位内存会放在数字的高位：
```c
 21 static inline word_t host_read(void *addr, int len) {
 22   switch (len) {
 23     case 1: return *(uint8_t  *)addr;
 24     case 2: return *(uint16_t *)addr;
 25     case 4: return *(uint32_t *)addr;
 26     IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr);
 27     default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0);
 28   }
 29 }
 30 
 31 static inline void host_write(void *addr, int len, word_t data) {
 32   switch (len) {
 33     case 1: *(uint8_t  *)addr = data; return;
 34     case 2: *(uint16_t *)addr = data; return;
 35     case 4: *(uint32_t *)addr = data; return;
 36     IFDEF(CONFIG_ISA64, case 8: *(uint64_t *)addr = data; return);
 37     IFDEF(CONFIG_RT_CHECK, default: assert(0));
 38   }
 39 }
```

## 表达式

 `str`成员的长度是有限的, 当你发现缓冲区将要溢出的时候, 要进行相应的处理(思考一下, 你会如何进行处理?), 否则将会造成难以理解的bug.答：直接`assert(0)`最快。


TODO： 编写测试中的表达式生成器。

## 监测点

`cpu-exec.c`若想要访问`monitor/sdb/sdb.h`中的函数，则直接将此函数在`cpu-exec.c`中再声明一下即可。**TODO：暂时不知道为什么可以在此处连接到函数的实现**。

Kconfig的生成位于`nemu/include/generated/autoconf.h`，出错了就去里面找问题。

Kconfig最最末端加上如下代码即可，会自动加上`CONFIG_`前缀：
```kconfig
config WATCHPOINT
	bool "Enable watchpoint"
	default y
```


# pa2

## RTFSC(2)

`exec_once()`会先把当前的PC保存到`s`的成员`pc`和`snpc`中, 其中`s->pc`就是当前指令的PC, 而`s->snpc`则是下一条指令的PC, 这里的`snpc`是"static next PC"的意思。

`isa_exec_once()`会随着取指的过程修改`s->snpc`的值, 使得从`isa_exec_once()`返回后`s->snpc`正好为下一条指令的PC。

`npc`是下一条静态指令, 而`dnpc`是下一条动态指令. 对于顺序执行的指令, 它们的`snpc`和`dnpc`是一样的; 但对于跳转指令, `snpc`和`dnpc`就会有所不同, `dnpc`应该指向跳转目标的指令. 显然, 我们应该使用`s->dnpc`来更新PC, 并且在指令执行的过程中正确地维护`s->dnpc`.

TODO：mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?

BITS取出x的二进制表示中高至hi位、低至lo位的数。

>BITS is a macro that is used to extract a specific range of bits from a given value x. It takes three arguments: x, hi, and lo.  The macro BITS uses the BITMASK macro to create a bitmask of the desired number of bits. The BITMASK macro shifts the value 1 left by the number of bits specified and then subtracts 1 to create a bitmask with all the bits set to 1.  
 The BITS macro then right-shifts the value x by the lo number of bits to align the desired range of bits with the least significant bits. It then performs a bitwise AND operation with the bitmask to extract the desired range of bits.  
 In summary, the BITS macro allows you to extract a specific range of bits from a given value x by specifying the high and low indices of the range. It is similar to the notation x[hi:lo] used in Verilog.

```c
#define BITMASK(bits) ((1ull << (bits)) - 1)  
#define BITS(x, hi, lo) (((x) >> (lo)) & BITMASK((hi) - (lo) + 1)) // similar to x[hi:lo] in verilog
```

```c
 21 #define R(i) gpr(i)
 22 #define Mr vaddr_read
 23 #define Mw vaddr_write
 24 
 25 enum {
 26   TYPE_I, TYPE_U,
 27   TYPE_N, // none
 28 };
 29 
 30 #define src1R() do { *src1 = R(rs); } while (0)
 31 #define src2R() do { *src2 = R(rt); } while (0)
 32 #define immI() do { *imm = SEXT(BITS(i, 15, 0), 16); } while(0)
 33 #define immU() do { *imm = BITS(i, 15, 0); } while(0)
```

INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);
```c
 89 // --- pattern matching wrappers for decode ---
 90 #define INSTPAT(pattern, ...) do { \
 91   uint64_t key, mask, shift; \
	  //解析pattern，与具体数据无关
 92   pattern_decode(pattern, STRLEN(pattern), &key, &mask, &shift); \
 93   if ((((uint64_t)INSTPAT_INST(s) >> shift) & mask) == key) { \
 94     INSTPAT_MATCH(s, ##__VA_ARGS__); \
 95     goto *(__instpat_end); \
 96   } \
 97 } while (0)
 98 
 99 #define INSTPAT_START(name) { const void ** __instpat_end = &&concat(__instpat_end_, name);
100 #define INSTPAT_END(name)   concat(__instpat_end_, name): ; }
```

```c
//src/isa/mips32/inst.c
 46 static int decode_exec(Decode *s) {
 47   int rd = 0;
 48   word_t src1 = 0, src2 = 0, imm = 0;
 49   s->dnpc = s->snpc;
 50 
 51 #define INSTPAT_INST(s) ((s)->isa.inst.val)
 52 #define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \
 53   decode_operand(s, &rd, &src1, &src2, &imm, concat(TYPE_, type)); \
 54   __VA_ARGS__ ; \
 55 }
 56 
 57   //添加指令模式
 58   INSTPAT_START();
 59   INSTPAT("001111 ????? ????? ????? ????? ??????", lui    , U, R(rd) = imm << 16);
 60   INSTPAT("100011 ????? ????? ????? ????? ??????", lw     , I, R(rd) = Mr(src1 + imm, 4));
 61   INSTPAT("101011 ????? ????? ????? ????? ??????", sw     , I, Mw(src1 + imm, 4, R(rd)));
 62   
 63   INSTPAT("011100 ????? ????? ????? ????? 111111", sdbbp  , N, NEMUTRAP(s->pc, R(2))); // R(2) is $v0;
 64   INSTPAT("?????? ????? ????? ????? ????? ??????", inv    , N, INV(s->pc));
 65   INSTPAT_END();
 66   
 67   R(0) = 0; // reset $zero to 0
 68   
 69   return 0;
 70 }
```

```c
 35 //取值
 36 static void decode_operand(Decode *s, int *rd, word_t *src1, word_t *src2, word_t *imm, int type) {
 37   uint32_t i = s->isa.inst.val;
 38   int rt = BITS(i, 20, 16);
 39   int rs = BITS(i, 25, 21);
 40   *rd = (type == TYPE_U || type == TYPE_I) ? rt : BITS(i, 15, 11);
 41   switch (type) {
 42     case TYPE_I: src1R(); immI(); break;
 43     case TYPE_U: src1R(); immU(); break;
 44   }
 45 }
```

```c
{ const void ** __instpat_end = &&__instpat_end_;
do {
  uint64_t key, mask, shift;
  pattern_decode("??????? ????? ????? ??? ????? 00101 11", 38, &key, &mask, &shift);
  if ((((uint64_t)s->isa.inst.val >> shift) & mask) == key) {
    {
      decode_operand(s, &rd, &src1, &src2, &imm, TYPE_U);
      R(rd) = s->pc + imm;
    }
    goto *(__instpat_end);
  }
} while (0);
// ...
__instpat_end_: ; }
```

### 第一个C程序

>am-kernels默认被gitignore了。

```bash
bash init.sh am-kernels
```

```bash
make ARCH=$ISA-nemu ALL=dummy run
```

```asm
  2 /home/ayana/workspace/ics2023/am-kernels/tests/cpu-tests/build/dummy-riscv32-nemu.elf:     file format elf32-littleriscv
  3 
  4 
  5 Disassembly of section .text:
  6 
  7 80000000 <_start>:
  8 80000000: 00000413            li  s0,0
  9 80000004: 00009117            auipc sp,0x9
 10 80000008: ffc10113            addi  sp,sp,-4 # 80009000 <_end>
 11 8000000c: 00c000ef            jal ra,80000018 <_trm_init>
 12 
 13 80000010 <main>:
 14 80000010: 00000513            li  a0,0
 15 80000014: 00008067            ret
 16 
 17 80000018 <_trm_init>:
 18 80000018: ff010113            addi  sp,sp,-16
 19 8000001c: 00000517            auipc a0,0x0
 20 80000020: 01c50513            addi  a0,a0,28 # 80000038 <_etext>
 21 80000024: 00112623            sw  ra,12(sp)
 22 80000028: fe9ff0ef            jal ra,80000010 <main>
 23 8000002c: 00050513            mv  a0,a0
 24 80000030: 00100073            ebreak
 25 80000034: 0000006f            j 80000034 <_trm_init+0x1c>
```

`INV`调用了`src/engine/interpreter/hostcall.c`的`void invalid_inst(vaddr_t thispc)`。

指令编码在riscv spec v1的Chapter 24: RV32/64G Instruction Set Listings。

li这种是pseudoinstructions，类似于宏定义，由其他指令实现。

查指令：[RISC-V Manual](https://jemu.oscc.cc/)

li看成addi。
































