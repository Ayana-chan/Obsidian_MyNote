

# 事务

## 四大特性

### **原子性（Atomicity）**

- **定义**：事务的所有操作要么**全部成功执行**，要么**全部不执行**（<u>回滚</u>到事务开始前的状态）。事务是不可分割的最小工作单元。

### **一致性（Consistency）**

- **定义**：事务执行前后，数据库必须**始终满足预定义的业务规则和约束**（如唯一性、外键、数据类型等），数据从一个有效状态转换到另一个有效状态。
- **作用**：确保数据逻辑正确性，防止违反业务规则。

### **隔离性（Isolation）**

- **定义**：并发执行的多个事务之间**互不干扰**，每个事务感知到的数据状态如同其他事务不存在。
- **作用**：防止并发操作引发的脏读、不可重复读、幻读等问题。
- **实现方式**：
    - **锁机制**：如行级锁、表级锁、共享锁（S锁）、排他锁（X锁）。
    - **多版本并发控制（MVCC）**：通过保存数据的历史版本，实现无锁并发读。天然保证不会有脏读。
    - **隔离级别**：提供不同强度的隔离保障：
        - **读未提交（Read Uncommitted）**：可能读到其他事务未提交的数据。
        - **读已提交（Read Committed）**：只能读到已提交的数据（默认级别）。
        - **可重复读（Repeatable Read）**：事务内多次读取同一数据结果一致。
        - **串行化（Serializable）**：事务完全串行执行，避免所有并发问题。

可恢复性(Recoverability)是说，对于一个调度，如果事务A读到了事务B的写入，并且事务A提交了，那么事务B一定在事务A之前提交(不能脏读)。（需要注意的是恢复相关的概念有很多，这里只是拿出了其中一个）(脏读会导致级联回滚, 因为一个事务会涉及很多其他事务).

严格两阶段锁协议除了 2PL 的要求外，还要求事务持有的 X 锁必须在事务结束后（COMMIT 或 ABORT）释放，这避免了未提交事务的更新被其他事务读取而导致的级联回滚。

更加严格的协议（**rigorous two-phrase locking protocol**）要求事务在结束（COMMIT 或 ABORT）之前，所有锁都不能释放，包括 S 和 X 锁，在该条件下，事务可以按提交顺序串行化。

### **持久性（Durability）**

- **定义**：事务一旦提交，其对数据的修改就是**永久性**的，即使系统崩溃或断电也不会丢失。
- **作用**：保障数据持久存储，防止提交后数据丢失。
- **实现方式**：
    - **Redo Log（重做日志）**：记录事务修改后的数据状态。系统崩溃后，通过重放日志恢复已提交事务。
    - **Write-Ahead Logging（WAL）**：先写日志到磁盘，再修改数据页，确保日志持久化。
    - **数据刷盘策略**：定期将内存中的脏页（修改后的数据页）刷入磁盘。



# 索引
## B+ 树


每个结点数据量很大, 因此深度往往会特别低(3~4层), 索引时间很短.

每次磁盘io会拿出完整的结点.

叶子结点存储所有东西, 能进行快速范围扫描(该过程没有磁盘io).


## 联合索引

一个索引能匹配多项。例如，一个唯一索引让abc三个字段组合是唯一的。
```sql
UNIQUE KEY `uniq_a_b_c` (`a`,`b`,`c`)
```

**最左匹配原则**：对于联合索引，如果一次定位使用了左前缀，则可以使用索引加速，否则无法被快速定位。例如，上面的索引，使用ab查询的话，速度也会特别快；但使用b或bc查询就都特别慢。



