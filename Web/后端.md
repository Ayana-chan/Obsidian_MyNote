# Maven
## 可选依赖
在dependency标签中设置optional为true，即可对上隐藏该依赖，也即取消该依赖的传递性。
## 排除依赖
在dependency标签中设置exclusions，使得在导入该dependency时防止导入exclusion指定的包。
## 聚合
使用聚合可以让一个工程统一管理其他多个工程，让多个maven一起运作。父主动管理子。用于快速构建项目。

新建一个聚合模块，将其packaging设为pom（表明用于聚合或继承）。然后使用modules以路径的形式配置要管理的各个模块。

```xml
<modules>
    <module>../maven_02_ssm</module>
    <module>../maven_03_pojo</module>
    <module>../maven_04_dao</module>
</modules>
```

会自动按照依赖关系决定的顺序进行加载。
## 继承
使用parent定义父工程，从父工程中继承依赖，简化依赖配置与版本管理。子主动依附父。用于快速配置。

以此可以把项目通用的依赖都放在父工程中。

```xml
<parent>
	<groupId>com.exm</groupId>
	<artifactId>fid</artifactId>
	<version>1.6.1</version>
	<!--定位到pom-->
	<!--空配relativePath则会去本地库和中央库中去找依赖包-->
	<!--不配可能会出bug-->
	<relativePath>../FatherFileName/pom.xml</relativePath>
</parent>
```

父工程也可以提供一些可选依赖,本质上是版本指定。子工程要用此依赖的话，在导入的时候不指定版本，默认使用父工程选择的版本。子工程也会继承dependencyManagement的设定。

```xml
<!--父工程-->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.16</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

```xml
<!--子工程-->
<dependencies>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
    </dependency>
</dependencies>
```

和依赖的区别是：
- 依赖会导入包含代码的整个工程，而继承只是继承一个pom。
- 依赖无法获取`<dependencyManagement>`。
## 属性
使用properties标签定义几个属性，可以在其他地方通过`${xxx}`的形式引用。

```xml
<properties> 
	<spring.framework>4.0.4.RELEASE</spring.framework> 
</properties>
```

`${project.basedir}`是一个内置属性，它能同时成为所有模块的根路径，可用于快速匹配存在于某一个模块中的某资源。

使用`mvn help:system`可以查看环境变量属性和Java系统属性。
## 问题
### 插件爆红
把插件的三属性放进dependency，刷新maven后即自动下载，之后删掉这些dependency即可。
### SpringBoot的‘parent.relativePath‘ of POM
[解决Maven ‘parent.relativePath‘ of POM问题 - 知乎](https://zhuanlan.zhihu.com/p/453547775)

通过添加`<relativePath/>`，使其父工程忽略项目直接从仓库里面找。注意，这会间接导致其他报错，因此要优先解决！
# Git
对于springboot的多模块项目（所有模块被聚合于上级），可以这样写`.gitignore`：

```gitignore
**/mvnw
**/mvnw.cmd

**/.mvn
**/target/

.idea

**/.gitignore
```

# SpringBoot
## 杂项
Application会扫描它所在的包及其子包。

测试类使用`@SpringBootTest`注解，并且application测试类应当和被测试的application放在同一个包路径下（否则要向注解中传入被测试类的class作为参数）以读取application中的配置。

如果要修改SpringBoot提供的依赖（如把tomcat换成其他服务器），则可以用exclusion去掉原依赖，然后导入对应依赖（也应当用SpringBoot提供的依赖）。
## 配置文件
一般使用yml后缀。读取顺序：`yaml`->`yml`->`properties`。因此`properties`优先级最高。

## 多环境
### 配置方式
配置`spring.profiles.active`的值即可。

```yml
spring:
	profiles:
		active: dev
```

之后可以使用`---`划分配置文件并使用`spring.config.activate.on-profile`来定义对应环境；也可以分多个文件进行配置（文件名后面加环境名，如`application-dev.yml`）。
### 通过Maven配置
应当使用maven的参数来控制环境的选择。

加入`maven-resource-plugin`插件即可让配置文件通过`${xxx}`获得maven中定义的参数，从而可以通过maven控制yml中`profiles.active`的值。

```xml
<!--引入插件-->
<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-resources-plugin</artifactId>
	<version>3.2.0</version>
	<configuration>
		<encoding>UTF-8</encoding>
		<useDefaultDelimiters>true</useDefaultDelimiters>
	</configuration>
</plugin>
```

```xml
<!--定义属性并指定默认值-->
<profile>
	<id>dev_env</id>
	<properties>
		<profile.active>dev</profile.active>
	</properties>
	<activation>
		<activeByDefault>true</activeByDefault>
	</activation>
</profile>
```

### 外部配置
在jar包同目录下写`application.yml`即可进行覆盖配置，优先级更高。

为上线服务，灵活配置。

## 整合Mybatis
Mybatis观察dao的返回值以辨别实体类。

使用`@Mapper`注解来定义dao类，使得Mybatis得以管理它。

```yml
spring:
	datasource:
		#高版本无需设时区
		url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC
		username: root
		password: 1234
		driver-class-name: com.mysql.cj.jdbc.Driver
		#使用Druid连接池
		type: com.alibaba.druid.pool.DruidDataSource
```

```yml
mybatis-plus:
	#开启驼峰功能，保证实体类属性正确映射数据表属性
	configuration:
	    map-underscore-to-camel-case: true
	#为未赋值的主键自动添加uuid
	global-config:
		db-config:
			id-type: uuid
```

# SpringCloud
## 分布式概念
- **集群**：多台机器即可叫集群，不要求协作。几台服务器可以组合在一起成为集群实现同一业务。
- **分布式系统**：多个计算机集合在一起，但对外等同于单一的系统。分布式中的每一个节点都可以做成集群。
- **节点**：集群中的一个服务器。
- **远程调用**：服务之间互相调用。SpringCloud使用HTTP+JSON进行远程调用。
- **服务注册/发现&注册中心**：记录各个服务器状态，确定哪些服务器能正常使用，提供上下线管理，记录“哪个服务在哪个服务器”清单。
- **配置中心**：服务器可以从配置中心中获取配置，从而可以统一管理配置。
- **服务熔断**：若被调用的*服务*失败程度达到一个阈值时，后来的请求都不再调用该服务，标记该服务为不可用（是服务不是服务器！）。此时上层服务会返回默认值。防止请求积压。
- **服务降级**：高峰期资源紧张，则让非核心业务*降级*，即简单处理（直接抛异常等）或不处理。
- **API网关**：抽象了微服务中都需要的*公共功能*，同时提供了客户端负载均衡，服务自动熔断，灰度发布，统一认证，限流流控，日志统计等丰富的功能，帮助解决API管理难题。前端的请求都要走网关过。
## 技术搭配方案
- **SpringCloud Alibaba-Nacos**:注册中心（服务发现/注册）
- **SpringCloud Alibaba-Nacos**:配置中心（动态配置管理）
- **SpringCloud-Ribbon**:负载均衡
- **SpringCloud-Feign**:声明式HTTP客户端(调用远程服务)
- **SpringCloud Alibaba-Sentinel**:服务容错（限流、降级、熔断）
- **SpringCloud-Gateway**:ApI网关（webflux编程模式）
- **SpringCloud-Sleuth**:调用链监控
- **SpringCloud-Alibaba Seata**:原Fescar，即分布式事务解决方案

## 版本对应关系
[版本说明 · alibaba/spring-cloud-alibaba Wiki · GitHub](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E)
## Nacos（注册/配置中心）
启动Nacos之后，访问`192.168.177.114:8848/nacos`即可进入管理界面。

### 注册中心
```xml
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>  
</dependency>  
<dependency>  
    <groupId>org.springframework.cloud</groupId>  
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>  
</dependency>
```

在`application`中对nacos服务器和注册名称进行配置即可完成注册：

```yml
spring:
  cloud:  
    nacos:  
      discovery:  
        server-addr: 192.168.177.114:8848  
        
  application:  
    name: gulimall-member
```
### 配置中心
```xml
<dependency>  
    <groupId>com.alibaba.cloud</groupId>  
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>  
</dependency>  
<dependency>  
    <groupId>org.springframework.cloud</groupId>  
    <artifactId>spring-cloud-starter-bootstrap</artifactId>  
</dependency>
```
#### 基本设置
添加配置文件`bootstrap.properties`，配置服务名和nacos地址。地址设置相当于注册中心的`discovery`换成`config`。

```properties
spring.application.name=gulimall-coupon  
  
spring.cloud.nacos.config.server-addr=192.168.177.114:8848
```

SpringCloud2.4以上的版本都需要导入`spring-cloud-starter-bootstrap`依赖才能启用对`bootstrap.properties`的扫描（它的优先级太高了，无法用`application`通知spring去扫描它，只能通过安装依赖解决）。

而在nacos网页上我们可以创建配置，名字为`应用名.properties`，选好文件格式后编辑配置文件。

此时，在nacos网页上发布的配置就能被程序用`@Value`直接获取到，和获取本地配置的方式一模一样。

但是，要加上`@RefrashScope`来使获取对应配置前进行刷新以应用配置的更改。

配置中心的配置优先级更高。

#### 命名空间
作用：配置隔离。

有两种情景：
- 开发、测试、生产三种环境下不同的配置文件。
- 每个微服务创建自己的命名空间，实现微服务之间的配置隔离。

切换命名空间（`dev`是命名空间id，默认是类似于uuid的字符串）：

```properties
spring.cloud.nacos.config.namespace=dev
```

#### 配置集
一些配置的集合就叫配置集，配置集有一个配置集ID，相当于配置文件名。此处配置集ID就是**Data ID**。

#### 配置分组
像命名空间一样筛选，比如双十一的时候切换到1111的group，或者也能用于切换开发、测试、生产三种环境。

```properties
spring.cloud.nacos.config.group=1111
```
## Feign（远程调用）
在member模块中`feign`包下创建`CouponFeignService`，通过`FeignClient`设置目标注册名称，通过`RequestMapping`设置目标路径名（也即通过url形式调用）。

```java
@FeignClient("gulimall-coupon")  
public interface CouponFeignService {  
  
    @RequestMapping("/coupon/coupon/member/list")  
    public R membercoupons();  
}
```

然后在Application上开启功能：
```java
@EnableFeignClients("cn.ayana.gulimall.member.feign")
```

这样，member模块里调用`couponFeignService.membercoupons()`即可获取coupon模块内`/coupon/coupon/member/list`对应的信息。








































