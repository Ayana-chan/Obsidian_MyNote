
# 一

令$B(n) = C(n) - 1$，则：

$$B(n) = \begin{cases}
0, n = 1 \\
2B(n/2) + n, n\geq 2
\end{cases}$$

可知$d = 0, a = 2, c = 2, b = 1, x = 1$。

可知$a = c^x$。

因此
$$B(n) = n\log_2n, n = 2^k, k \in \mathbb{N}^*$$

从而得到
$$C(n) = n\log_2n + 1, n = 2^k, k \in \mathbb{N}^*$$

因此渐进复杂度为$O(n\log_2n)$。

# 二

## (1)

- Prim 时间复杂度：$O((V+E)logV)$
- Kruskal 时间复杂度：$O(ElogE)$

因此，稠密图用Prim，稀疏图用Kruskal。

$E \geq VlogV$时，用Prim；否则用Kruskal。


## (2)

这种集成使其能同时适应稠密图和稀疏图，在图的疏密程度变化较大的场景下的平均性能更好。


# 三

假设$HeapPermute(n)$：
1. 当$n$为偶数的时候，输出前$n$项的全排列，并且数组$A$循环右移一位。
2. 当$n$为奇数的时候，输出前$n$项的全排列，并且数组$A$回到初始态。

使用数学归纳法，显然n=1时成立。

---

当n为**偶数**时，假定**假设1**成立，则每次调用$HeapPermute(n)$都会输出A的前n项的全排列后循环右移一位。

因此，$HeapPermute(n+1)$调用$n+1$次$HeapPermute(n)$时，每次调用都会输出前$n$位的全排列，再对前$n$项进行循环右移，并把第一位和$n+1$位交换；其等价于对前$n+1$项进行<u>循环右移</u>。可见，每次在第$n+1$处的元素都不同。

因此，遍历完成后就得到了$n+1$组数据，每一组数据都是不同的元素结尾前面带上剩余元素的全排列；显然，这就是前$n+1$个数的全排列。

另外，完成$n+1$次调用后就等价于对数组的前$n+1$项进行$n+1$次循环右移，这使得最终数组与初始时一样。

于是对于$n+1$（奇数），**假设2**成立。

---

当n为**奇数**时，假定**假设2**成立，则每次调用$HeapPermute(n)$都会输出A的前n项的全排列后回归原位。

因此，$HeapPermute(n+1)$调用$n+1$次$HeapPermute(n)$时，每次调用都会输出前$n$位的全排列，并再把不同的数放在$A[n+1]$处。

因此，遍历完成后就得到了$n+1$组数据，每一组数据都是不同的元素结尾前面带上剩余元素的全排列；显然，这就是前$n+1$个数的全排列。

另外，每次调用完$HeapPermute(n)$时，都让一个元素右移了一位（最后一个元素移到第一位），完成$n+1$次调用后就等价于对前$n+1$项进行了一次循环右移。

于是对于$n+1$（偶数），**假设1**成立。

---

综上所述，两个假设对所有$n$成立。因此对所有$n$，恒有$HeapPermute(n)$会输出全排列。得证。


# 四


```
vector arr(n)
ans = 0
minNum = arr[0]
find(arr, 1)

// find min element in arr at [begin,end]
fn find(begin) {
	if(begin == n) {
		return;
	}
	if(arr[begin] < minNum) {
		ans = begin
		minNum = arr[begin]
	}
	find(begin + 1)
}

return ans
```

遍历次数固定为$n$，每次遍历进行常数次操作，因此为$O(n)$。

理论复杂度与蛮力版本完全相同，尾递归优化使其实际性能消耗也相同。


# 五

若有$2n$人，编号为$1,2,\dots, 2n$，从$1$开始动手；那么杀了一圈后会留下$1,3,\dots, 2n-1$，从$1$开始动手。可见，剩下的人构成了$n$个人的子问题，且恒有下标映射$cur = 2sub-1$；所以，在子问题中存活了下标$J(n)$的话，就相当于在本问题中存活了下标$2J(n)-1$。因此，有：
$$J(2n) = 2J(n)-1$$

若有$2n+1$人，编号为$1,2,\dots, 2n+1$，从$1$开始动手；那么杀了一圈后会留下$3,\dots, 2n+1$，从$3$开始动手。可见，剩下的人构成了$n$个人的子问题，且恒有下标映射$cur = 2sub+1$；所以，有：
$$J(2n+1) = 2J(n) +1$$


可知$J(2n+1) = J(2n) + 2$。

由$J(2n) - 1 = 2[J(n) - 1]$和$J(1) = 1$可得
$$J(n) = 1, n = 2^k, k \in \mathbb{N}$$

TODO





