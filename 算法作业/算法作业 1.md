
# 一

令$B(n) = C(n) - 1$，则：

$$B(n) = \begin{cases}
0, n = 1 \\
2B(n/2) + n, n\geq 2
\end{cases}$$

可知$d = 0, a = 2, c = 2, b = 1, x = 1$。

可知$a = c^x$。

因此
$$B(n) = n\log_2n, n = 2^k, k \in \mathbb{N}^*$$

从而得到
$$C(n) = n\log_2n + 1, n = 2^k, k \in \mathbb{N}^*$$


# 二

## (1)

- Prim 时间复杂度：$O((V+E)logV)$
- Kruskal 时间复杂度：$O(ElogE)$

因此，稠密图用Prim，稀疏图用Kruskal。

$E \geq VlogV$时，用Prim；否则用Kruskal。


## (2)

这种集成使其能同时适应稠密图和稀疏图，在图的疏密程度变化较大的场景下的平均性能更好。


# 三

TODO


# 四


```
vector arr(n)
ans = 0
minNum = arr[0]
find(arr, 1)

// find min element in arr at [begin,end]
fn find(begin) {
	if(begin == n) {
		return;
	}
	if(arr[begin] < minNum) {
		ans = begin
		minNum = arr[begin]
	}
	find(begin + 1)
}

return ans
```

遍历次数固定为$n$，每次遍历进行常数次操作，因此为$O(n)$。

理论复杂度与蛮力版本完全相同，尾递归优化使其实际性能消耗也相同。


# 五

若有$2n$人，编号为$1,2,\dots, 2n$，从$1$开始动手；那么杀了一圈后会留下$1,3,\dots, 2n-1$，从$1$开始动手。可见，剩下的人构成了$n$个人的子问题，且恒有下标映射$cur = 2sub-1$；所以，在子问题中存活了下标$J(n)$的话，就相当于在本问题中存活了下标$2J(n)-1$。因此，有：
$$J(2n) = 2J(n)-1$$

若有$2n+1$人，编号为$1,2,\dots, 2n+1$，从$1$开始动手；那么杀了一圈后会留下$3,\dots, 2n+1$，从$3$开始动手。可见，剩下的人构成了$n$个人的子问题，且恒有下标映射$cur = 2sub+1$；所以，有：
$$J(2n+1) = 2J(n) +1$$


TODO






