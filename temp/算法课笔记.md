# 关键词

- recursion 递归
- substitution 代替，代换
- induction 归纳
- recurrences 复现，重现
- auxiliary 辅助的，备用的

# 小记

证明O(.)时，n的取值要保证原函数为正。c和n都是正。

O为上界，Ω为下界，两者等同时就有θ。

分治算法： $T(n)=aT(n/b)+D(n)+C(n)$ a为子问题量，b为规模缩减率，D为divide耗时，C为combine耗时。

递归树：T(n)为每一层的D、C耗时加上叶子结点的处理耗时

堆的节点的高度：算上自己，到叶子结点的最大结点总量。

将无需数组变成大顶堆：从下而上遍历所有父结点，若比孩子小则交换。O(n)

堆排序：将根和最后一个堆中结点交换，然后O(lgn)调整为堆。如果是大顶堆的话相当于把最大值固定到后面，到最后结果就是正序。

主定理：
![](assets/uTools_1686234296391.png)

矩阵连乘dp方程：
![](assets/Pasted%20image%2020230609000925.png)

Dijkstra正确性：若存在被标记的点v，其路径不为最短路径，则这个点的最短路径中存在一个点u，u不在v目前路径上的，且u必然没被标记（否则最短路径必然能检测到u）；u的距离必然小于v的距离（因为所有边都是正数），因此u必然比v先被标记，出现矛盾。因此被标记的就为最短路径。



